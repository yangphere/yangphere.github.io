{"posts":[{"title":"ja-netfilter 适配 Java25","content":"咱们长话短说，Java 25 移除了内置的 ASM 包，所以 ja-netfilter 的有些插件在 Java 25 版本用不起了。 解决起来也很简单，不用内置的 ASM 包就好了，把 ASM 包直接打进 ja-netfilter。如此各插件也就都能用上。 这样做有一个额外的好处，不用添加额外的模块依赖，比如之前我们在 Java 17 加进去的： --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 现在可以移除了。不过也有缺点，那就是因为额外把 ASM 打进去了，导致 ja-netfilter 包的大小多了 200K 的样子。但我想 2025 年了，谁也不缺这 200K 的硬盘吧。 代码我已经提交到仓库，也打好包方便各位使用：https://gitee.com/ja-netfilter/ja-netfilter/releases/tag/2025.3.0 。将对应的 ja-netfilter.jar 和插件都替换即可。 请各位在非官方仓库下载包时，一定一定记得到官方仓库比对 sha1sum 值！ 据闻有坏种使用篡改的 jar 包在植入木马了！ 我直接将 ja-netfilter 2025.3.0 相关文件的 sha1sum 公布在博文中吧： 488126a2eb9ddf87e2092a3cdf39cdc6762306cd ja-netfilter.jar c6757d325d86fbf6f64fa76e84c5dfb9ef8381ba plugins/dns.jar c3e3b71d6c5cab0172f05c465aabedaf6594fb26 plugins/env.jar e99ea3b8884a373c08a08eb51bccd88a8d29df0a plugins/hideme.jar 14edc0d7e30238ec9f779c0ff12a64ada5f72a7a plugins/native.jar 6519162355edecde54c4dfc21afdd523be0a7b5a plugins/power.jar f8518727b7d36e0e55825175d0a1e9a583153a63 plugins/url.jar 6afbd2bbb5d03ed0947ca313e000af44d4aea389 README.pdf 我不想产生额外的联想，但这篇博文还是值得大家去看的：https://zhile.io/2024/09/05/jetbrains-2024-2-region.html ","link":"https://blog.coolcode.dev/post/ja-netfilter-gua-pei-java25/"},{"title":"JetBrains新版本区域选择的坑","content":"好久不见啊，朋友们！ JetBrains新版本(2024.2)在设置里添加了区域选择，具体在：Appearance &amp; Behavior -&gt; System Settings -&gt; Language and Region -&gt; Region 中设置。如果你选择 China Mainland 将会有一个比较坑的地方：激活许可验证走 account.jetbrains.com.cn 这个域名，而不是默认的 account.jetbrains.com 。 这将导致一个问题：热佬的整合包里，没有对这个域名的拦截，会联机然后发现许可被吊销。 热佬可能打仗太忙，尚未发布新包。不过这个问题解决起来也很简单，找到你的jetbra目录，编辑 config-jetbrains\\url.conf 文件，新增以下内容保存即可： [URL] PREFIX,https://account.jetbrains.com.cn/lservice/rpc/validateKey.action 也就是把新的域名也拦截咯。 ","link":"https://blog.coolcode.dev/post/jetbrains-xin-ban-ben-qu-yu-xuan-ze-de-keng/"},{"title":"关于ja-netfilter适配Java17的问题","content":"这两天总有人私信或评论跟我说：大事不好了，ja-netfilter在Java17里用不起了！ 这事听着就新鲜！我心想早在5月20日的提交中，我就兼容了Java17并且写在README里了。 所以，这个事情我本没当回事，直到问的人越来越多。细问之下，原来是JB家所有IDE2022.2版本默认启用Java17。 故有写此短文专门来解释一下。 首先，请看项目的README.md，自认为写的是非常清楚了： for Java 17 you have to add at least these JVM Options: --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 简单来说就是要在Java17中使用ja-netfilter，你需要： 你需用5月20日发布的ja-netfilter-v2022.2.0版本，否则可能无法启动。 你需添加这两条JVM参数，否则ja-netfilter无法访问Java17内置的ASM包。 JVM参数是加在启动命令里，还是加在JVM参数文件里，都可以。 至于为什么Java17要加这个配置，这是JVM规定的。你不加，项目用到的某些类就访问不到。具体你可以看这里。 最后，使用一个工具，请养成先通读README的习惯！ ","link":"https://blog.coolcode.dev/post/guan-yu-ja-netfilter-gua-pei-java17-de-wen-ti/"},{"title":"介绍一个”牛逼闪闪”开源库：ja-netfilter","content":"上来先说点题外话，很多人最新私信我说我的开源项目IDE Eval Resetter不好用了。我就问他为什么不好用了，不好编译了吗？他说不是，是不能在IDE上重置了。我心说，这是个学习研究项目，重在学习插件写法，不能用也实在属于正常。于是我去测试了一下，得出了个结论：2021.2.2及以下版本很好用；2021.3以下（不含）堪堪能用，需要配合一些手法；2021.3版本开始正式失效，你可以卸载这个插件了！ 所以没错，IDE Eval Resetter这个项目我已经弃坑，因为我觉得我插件已经写得很好了（手动狗头，以下很多用词默认手动加了狗头），得玩点其他好玩的东西。 这次要来玩个正经的、通用的、高大上的东西。 0x0. 项目背景 首先还是基于上述内容。 我们日常使用的软件中有很多有意或无意被加入网络访问的代码。有些并非恶意，有些则是。 并非恶意的像一些软件的在线激活验证，如dbeaver、smartgit等。 恶意的像有些软件本身就有盗取用户隐私数据的情况，有些软件则是被一些别有用心的人二次加工放入偷取用户数据的代码。 我们通常会使用防火墙来阻断这些软件的恶意访问。但防火墙也不是万能的，比如：跨平台问题、https下无法精准阻断某个url访问、部分防火墙不能阻断dns访问。 于是就有了我今天开源的这个项目：通用的、针对java程序的、灵活的、精准基于规则的、基于AOP思想的牛逼哄哄防火墙（无数狗头）：ja-netfilter！ 0x1. 如何安装 1). 下载安装： 直接到项目仓库的Releases页面下载我打包好的文件包。 按照项目README.md所写的方式来配置-javaagent参数。某些软件像dbeaver和smartgit等软件都支持直接编辑配置文件来配置，你可以参考我之前写的agent帮助文件来配置，这里不赘述。 编辑config目录下的对应配置文件，配置希望阻断的规则。具体见下面的配置文件部分。 1). 编译安装： 直接到项目仓库页面下载源文件，编译出目标jar文件即可。 同下载安装部分。 0x2. 如何使用 按照上述安装配置好后直接启动目标程序即可。 你甚至能跟你的tomcat或jetty一起使用，来防止你项目依赖包中的一些恶意请求。 0x3. 如何更新 关注上述的开源项目即可获取最新的代码和编译好的包。 0x4. 配置文件 在ja-netfilter.jar同目录中有个conf文件夹，其内存放了所有插件的配置文件，命名为：插件名(小写).conf 至于配置文件的编写，项目帮助文档中已经写出，这里不再重复说明了。只是简单列举几个例子： DBEaver 阻断激活验证的 url.conf 配置文件 [URL] PREFIX,https://dbeaver.com/lmp/checkLicense SmartGit 的 url.conf 配置文件 [URL] PREFIX,https://store.smartgit.com/check jb 的 dns.conf 配置文件 [DNS] EQUAL,jetbrains.com jb 的 url.conf 配置文件 [URL] PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action 0x5. 开源信息 插件是学习研究项目，源代码是开放的。源码仓库地址：ja-netfilter。 这是个通用的软件包，配置文件灵活自由，请不要过度想象。 请不要试图结合IDE Eval Resetter一文中所说热心大佬的key来使用本项目。赶快入正！赶快入正！赶快入正！ 如果你有更好的想法，欢迎给我提Pull Request来共同研究完善。 插件源码使用：GPL-3.0开源协议发布。 插件使用PHP编写，毕竟PHP是世界上最好的编程语言！ Telegram group: ja-netfilter Telegram channel: ja-netfilter channel QQ Group: 638451028 0x6. 支持的产品 本防火墙基于javaagent，所以目前只有基于java的程序能够使用。更通用的防火墙，等我学习更多知识。 0x7. 插件机制 新版本ja-netfilter已经支持插件机制，各位可以给它开发各种各样有趣的插件了。 插件开发请见这个脚手架项目。 插件丢进ja-netfilter.jar所在的plugins子目录即可加载。 Power插件应用：搞定YouTrack和Upsource 下面是国际惯例： 本项目只做个人学习研究之用，不得用于商业用途！ ","link":"https://blog.coolcode.dev/post/jie-shao-yi-ge-niu-bi-shan-shan-kai-yuan-ku-ja-netfilter/"},{"title":"解决Host key verification failed","content":"一、发现问题 问题如下图代码： $ ssh root@108.61.163.242 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:HDjXJvu0VYXWF+SKMZjSGn4FQmg/+w6eV9ljJvIXpx0. Please contact your system administrator. Add correct host key in /Users/wangdong/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /Users/wangdong/.ssh/known_hosts:46 ECDSA host key for 108.61.163.242 has changed and you have requested strict checking. Host key verification failed. 这里面，有一句很关键。 ECDSA host key for 108.61.163.242 has changed and you have requested strict checking. Host key verification failed. 一般这个问题，是你重置过你的服务器后。你再次想访问会出现这个问题。 二、解决问题 解决问题也很简单： ssh-keygen -R 你要访问的IP地址 例如： ssh-keygen -R 108.61.163.24 贴个图更直观 ","link":"https://blog.coolcode.dev/post/jie-jue-host-key-verification-failed/"},{"title":"把git的默认分支master修改成main","content":"修改初始化项目时，默认使用main作为主分支 git config --global init.defaultBranch main 已经创建项目的主分支为master，切换到master分支，重命名main git branch -M main ","link":"https://blog.coolcode.dev/post/ba-git-de-mo-ren-fen-zhi-master-xiu-gai-cheng-main/"},{"title":"2023年11款好用的笔记软件推荐","content":"如果说有什么软件适合所有人的，那么云笔记一定算一个，不管你是用来分享看法、记录灵感、总结知识等，都可以使用云笔记软件来完成，一款好用的笔记软件不仅能记录笔记，更能帮助你提升知识管理的效率，在本文中，我们就来推荐几款好用的笔记软件 Notion Notion 是一款多合一的笔记软件，它把非常多的功能都做到了软件中，看板、日历、表格、列表等多种数据展现方式，你可以用这些来构建自己的知识库 在Notion中，除了有非常多的功能样式外，最大的特色就是所有的区块都是可以联通的，你可以在一篇笔记中嵌入另一个笔记的内容，可以是看板、日历等多种格式，而且可以无限的嵌套；对于一些有固定格式的笔记，你可以添加自定义字段，保存成模版，方便后期添加更多相似内容；还可以在自己的笔记中嵌入其他的第三方服务比如视频、Github代码等，或者将自己的笔记分享给他人 优点： 模块化，可以随意调整笔记 嵌套支持，在同一页面查看多个状态 表格、看板、日历等多视图数据库，可任意切换 笔记模版，支持制作和导入 第三方嵌入支持，支持代码、视频等嵌入 内容发布，可以发布、分享页面 缺点： 没有中文语言，很多功能需要学习 Notion是一个非常强大而且扩展性很强的笔记软件，你可以灵活的使用，将其变成自己需要的笔记软件，适合作为个人或者工作的管理工具，而且现在Notion针对个人计划已经完全免费了，无需升级就能使用无限Block，免费版大部分都足够了 Notion教程 如何用Notion记笔记 Obsidian Obsidian 是一款基于Markdown的笔记软件，它支持Windows、macOS、iOS和Android，它可以让你用Markdown文件构建起自己的知识库，不同于其他笔记使用自己的格式，Obsidian 中所有的笔记都是独立的Markdown文档，你可以使用Obsidian来撰写笔记，也可以使用其他的Markdown编辑器比如Typora、iA Writer等来编辑，即使未来有一天你不再使用Obsidian，也能够轻松管理自己的笔记 优点： 基于Markdown语法，可显示预览 双向链接 知识图谱 插件系统 本地管理且支持云同步 缺点： 部分功能需付费 对于喜欢Markdown的用户来说，Obsidian 是一款很值得使用的笔记工具 Obsidian 基于Markdown的知识管理工具 RemNote RemNote 是一款大纲形式的笔记软件，它专为学习者打造，能够让你记录和学习知识，在RemNote中有三大功能：大纲笔记、智能闪卡和文档标注，每个功能都有其用途，你可以用大纲笔记来记录知识和每天的想法，使用闪卡来复习之前记录的内容，使用文档标注功能来对PDF、网页等进行标注，每个功能都可以结合起来使用，让你不必再到多个应用中进行切换，还可以使用双向链接和知识图谱来链接笔记，将不同的知识联系起来方便管理和查阅 RemNote 是一款非常好用的大纲笔记软件，而且很多功能都可以免费使用，如果你想要体验双向链接的大纲笔记的话，它是一个很好的选择 Evernote 作为一款老牌的笔记软件，Evernote 确实是一款适合每个人使用的软件，首先是其强大的笔记分类功能，可以通过笔记本和标签来对笔记进行分类，你还可以在笔记内添加表格、待办、代码等多种元素，对于信息收集，可以用它的剪藏插件快速收集信息，提升你的工作效率 优点： 服务稳定 免费云同步 网页剪藏 离线支持 可以轻松切换到大多数笔记 缺点： 笔记界面不够简洁 免费版每月60M的上传流量限制 免费版限制2同步设备 虽然笔记软件已经非常多了，但是Evernote仍然是值得使用的笔记软件，服务稳定，虽然不付费的话有一些限制，但是对于很多人来说，免费版的功能就足够使用了，另外即使你哪一天不再使用Evernote了，也可以轻松地切换到其他笔记软件 OneNote OneNote是微软旗下的云笔记软件，在其他笔记中，不管是什么功能，大部分都是以文字记录为主，按照常规来记录，OneNote则有很大的不同 首先在它的功能介绍中，就是以图片为主，它允许人们在笔记中进行勾画和书写，可以在白色的背景、或者带有网格的背景上进行写作，或者描绘。如果你大部分时间使用文字记录，或者刚刚使用OneNote，可能会非常不习惯它的记录方式，因为你可以在任何地方写作、记录、做标记等等，尤其在触屏设备中，给人的体验更像真实的记录一样，你还可以用Apple Pencil 把它当作一个手写笔记 优点： 免费云同步 手写支持好 自由随意的笔记 手写转文字、公式 缺点： 新手可能使用起来不习惯 不适合纯文字的记录 OneNote这款软件最大特点就是自由，使用它你就像在使用一张白纸，所有的内容、位置、图片等都由你自己决定，不过它的缺点也是太自由，导致想要用OneNote写出规整的笔记并不容易，你需要面对各种对齐、文字大小、笔画等问题 Craft Craft 是一款苹果平台的笔记软件，它和Notion非常类似，都采用了模块化的编辑器，你可以轻松插入不同格式的笔记，不过Craft这款笔记更注重性能，你可以更流畅地写作，操作和调整块，而且软件对离线有很好的支持，即使是没有网络，也能正常的记录和查看笔记 Craft 非常适合作为文档写作，你可以灵活地组织页面，在页面中嵌入子页面，在页面间建立链接，添加图片和视频搭建起自己的知识库，还可以通过网页分享自己的文档知识库 Craft Mac上原生的模块化笔记应用 Simplenote Simplenote 是由Automattic推出的一款轻量级笔记软件，这款软件真的是就如它的名字一样，非常的简单，注册一个账号马上就可以写东西 优点： 界面简洁 全平台支持 免费云同步 Markdown支持 版本管理 笔记分享 缺点： 没有分类 Simplenote非常简洁，而且软件完全免费，很适合那些单纯想写写文字的人 Simplenote 免费实用的极简笔记软件 熊掌记 熊掌记是一款MAC平台的笔记应用，以轻量和优雅为特色，适合于文字写作者 相比于其他的笔记软件，熊掌记不仅有着非常高的颜值，在使用上也更为简洁与流畅，轻量的设计让其启动速度非常快，配合IOS设备，可以随时记录任何想法 优点： 轻量，软件打开速度快 高颜值、界面简洁，专注文字记录 所见即所得Markdown语法 多样的标签用法 多种主题可切换，还可以替换软件图标 免费版除云同步外可使用大部分功能 缺点： 仅有macOS和iOS版本 熊掌记是非常好用的Markdown笔记软件，极简的设计，流畅的体验，很适合作为个人笔记软件使用，对于喜欢轻量和快捷笔记的人来说是一款值得选择的笔记软件 熊掌记 轻量高颜值的笔记工具 Day One Day One 是一款非常好用的日记软件，它支持Mac、iOS、Android，让你可以在任意的设备上随时记录。在 Day One 中，你可以插入各种形式的内容作为笔记，包括文字、照片、视频、音频、绘画等，而且在插入媒体的同时 Day One 会帮你处理很多东西，比如插入照片，它会自动识别照片的拍摄地点和时间，创建对应时间的笔记，还有一些特定的信息比如位置、使用的设备、写日记时的天气、创建和修改日期等，你可以用Day One 来帮助记录生活 除了记录形式多样外，Day One 的回顾和查看也非常的方便。它有一个强大的过滤器，你可以根据照片、视频、日期、地点、标签、活动等多个维度结合进行筛选，比如你可以筛选出今年所有带音频的笔记，也可以查看在某个地方拍摄的所有视频。在回顾上，你可以查看自己的写作日历，拍摄的所有照片，甚至旅行路线等都可以直观地展示出来 Roam Research Roam Research 是一款新型的笔记软件，它并没有使用传统的文件夹或标签形式来组织笔记，而是通过各种形式将你的知识连接起来建立网络，让你更灵活地管理自己的笔记，通过每天的点滴记录，你可以无压力地搭建起自己的个人知识库 优点： 大纲笔记，建立结构更清晰和易于编辑的笔记 Markdown语法支持，可以快速创建各种形式的笔记 双向链接，可以在链接的笔记中查看相关的引用，快速查找相关知识 内容可视化，以图形的方式查看知识网络，预览笔记内容 缺点： 价格略高 上手需要一些时间 相比其他软件，Roam Research 有很多创新性的功能，如果你想要体验与之前不同的记笔记方式，它是一个很好的选择 Milanote Milanote 是一款灵活且多功能的笔记工具，你可以将它作为一个白板使用，记录自己的各种内容，和传统的文字笔记相比，Milanote中的笔记非常灵活，可以是笔记、图片、视频、待办事项等，而且你可以随时调整这些卡片，使其帮助自己更好地思考，对于设计和创意工作者来说是一款非常值得使用的工具 Milanote 为创意工作者打造的笔记工具 以上就是本文分享的几款云笔记软件，不管选择哪一款，基本都能实现大部分记录需求，不过要想更高效地使用笔记，还是要选择适合自己的，笔记软件一般都提供了免费版本，你可以使用后选择适合自己的笔记软件 ","link":"https://blog.coolcode.dev/post/2023-nian-11-kuan-hao-yong-de-bi-ji-ruan-jian-tui-jian/"},{"title":"最适合程序员的笔记软件","content":"作者： 阮一峰 日期： 2021年8月26日 程序员的笔记软件，应该满足下面几个条件。 （1）跨平台，同时支持桌面电脑（Windows，Mac，Linux）和手机（Android，iOS）。 （2）随时同步，打开任何一台机器，都能接着上一次的工作继续写。 （3）实时存储，如果软件突然关闭，也不会丢失内容。 （4）支持 Markdown 格式，便于后期直接发布。 （5）支持推送到远程 Git 仓库，产生历史版本，同时作为远程备份。 我一直在寻找符合这些条件的工具，但是市场上大部分的笔记软件，都不支持上面的第5点，Git 集成要么没有，要么很弱。 我用过 Stackedit.io 和 HackMD.io，都不是很理想。 最近，我终于找到了最佳方案，那就是 GitHub 官方推出的 github.dev。 只要访问下面的网址，你就能在浏览器里面，使用 VS Code 编辑指定仓库。可以点击这里体验一下。 https://github.dev/[用户名]/[仓库名] 它实际上就是 VS Code 编辑器的 Web 版，并且与 Git 高度集成。这种组合，还有什么笔记软件会比它更强！ 使用时，首先在 GitHub 上面新建一个笔记仓库，公开或私密都可以。然后使用 github.dev 编辑完，再推送回仓库。换到其它机器时，就先从仓库获取文档的最新版本，简直是完美的解决方案。 更棒的是，GitHub 提供了一个快捷入口。 打开 GitHub 仓库主页，按一下小数点（.）这个键， 页面就会自动跳转到 VS Code 编辑环境，真是太方便了。 另外，还有一个非官方的 github1s.com，也提供类似功能。只要在仓库域名的里面，加上&quot;1s&quot;就可以了。但毕竟是非官方工具，这里就不推荐了。 https://github1s.com/[用户名]/[仓库名] github.dev 针对的是桌面的&quot;键盘 + 鼠标&quot;环境，手机触摸屏可以使用，但终归很笨拙。 如果你更希望使用手机原生 App，我推荐 Obsidian。它有全平台的客户端，并且可以参考这篇文章设置 Git 集成。 另外，FSNotes 也不错，可惜只支持苹果设备。 如果你不需要 Git 集成和 Markdown 支持，那就最简单了，几大软件巨头的官方笔记 App，就非常好用：Google keep、Apple Notes（只支持苹果设备）和微软 OneNote。 它们都是自动多端同步，缺点是不便于编写大型文档，以及导出数据很麻烦。 （完） ","link":"https://blog.coolcode.dev/post/zui-gua-he-cheng-xu-yuan-de-bi-ji-ruan-jian/"},{"title":"从 JDK 11-JDK 20，谁修复的 issue 最多？","content":"JDK/Java 20 已正式 GA。根据 Oracle 披露的信息显示，在为 JDK 20 修复的 issue 数量上，位列全球前五位的厂商分别为：甲骨文（Oracle）、红帽（Red Hat）、思爱普（SAP）、ARM 和腾讯（Tencent）。其中，来自国内的积极贡献厂商除腾讯外，还有阿里巴巴、华为和龙芯。 “我们感谢许多审查提议更改的经验丰富的开发人员、尝试早期访问构建并报告问题的早期采用者，以及在 OpenJDK 邮件列表上提供反馈的敬业的专业人员。” 公告指出，在 Java 20 中，被标记为已修复的 2314 个 JIRA issue 里面，有 1595 个由 Oracle 的雇员修复，其余的 719 个由 Java 社区的其他个人开发者和组织开发者贡献修复。 Oracle 感谢了阿里巴巴、亚马逊、ARM、谷歌、华为、IBM、英特尔、ISCAS、红帽、SAP 和腾讯等组织的开发者做出的显著贡献，以及来自 Bellsoft、龙芯等小型组织独立开发者的贡献，他们总计为 Java 20 中 7% 的 issue 贡献了修复。 而从 Java 11 到 Java 20 GA 发布，在被标记为已修复的 21604 个 JIRA issue 中；Oracle 的雇员修复了 15420 个，剩余的 6184 个由个人开发者和其他组织的开发者贡献修复。其中，修复数量排在前五位的厂商分别为：Oracle、Red Hat、SAP、Google 和腾讯。通过检查 issue 并整理来自指派者结果的组织数据后，可以得出以下组织在 Java 中的开发贡献图表： 此外，Oracle 还特别感谢了开发者 Rick Hillegas 和 Apache Derby 团队，“感谢他们多年来在每个 JDK 版本的抢先体验测试周期中提供的可靠且定期的反馈”。 ","link":"https://blog.coolcode.dev/post/cong-jdk-11-jdk-20shui-xiu-fu-de-issue-zui-duo/"},{"title":"使用acme-tiny工具生成Let's Encrypt的免费SSL证书","content":"下载acme-tiny 下载地址：https://github.com/diafygi/acme-tiny 创建用户私钥和域名私钥 mkdir -p /etc/ssl/letsencrypt/ cd /etc/ssl/letsencrypt/ openssl genrsa 4096 &gt; account.key openssl genrsa 4096 &gt; domain.key 生成域名csr文件 单域名 openssl req -new -sha256 -key domain.key -subj &quot;/CN=www.yoursite.com&quot; &gt; domain.csr 多域名 ln -s /etc/pki/tls/openssl.cnf /etc/ssl/openssl.cnf openssl req -new -sha256 -key domain.key -subj &quot;/&quot; -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(printf &quot;[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com&quot;)) &gt; domain.csr 配置web站点的challenge文件 mkdir -p /var/www/challenges/ #example for nginx server { listen 80; server_name yoursite.com www.yoursite.com; location /.well-known/acme-challenge/ { alias /var/www/challenges/; try_files $uri =404; } ...the rest of your config } 生成signed文件 wget -c https://raw.githubusercontent.com/yangphere/acme-tiny/master/acme_tiny.py --no-check-certificate python acme_tiny.py --account-key /etc/ssl/letsencrypt/account.key --csr /etc/ssl/letsencrypt/domain.csr --acme-dir /var/www/challenges/ &gt; /etc/ssl/letsencrypt/signed.crt 生成证书链 v1版，兼容性差点 wget -O - https://letsencrypt.org/certs/lets-encrypt-x1-cross-signed.pem &gt; /etc/ssl/letsencrypt/intermediate.pem cat /etc/ssl/letsencrypt/signed.crt /etc/ssl/letsencrypt/intermediate.pem &gt; /etc/ssl/letsencrypt/chained.pem 建议使用v3版 wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; /etc/ssl/letsencrypt/intermediate.pem cat /etc/ssl/letsencrypt/signed.crt /etc/ssl/letsencrypt/intermediate.pem &gt; /etc/ssl/letsencrypt/chained.pem 生成dh证书 openssl dhparam -out dhparam.pem 2048 配置nginx使SSL证书生效 server { listen 443; server_name yoursite.com, www.yoursite.com; ssl on; ssl_certificate /etc/ssl/letsencrypt/chained.pem; ssl_certificate_key /etc/ssl/letsencrypt/domain.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA; ssl_session_cache shared:SSL:50m; ssl_dhparam /etc/ssl/letsencrypt/dhparam.pem; ssl_prefer_server_ciphers on; ...the rest of your config } server { listen 80; server_name yoursite.com, www.yoursite.com; location /.well-known/acme-challenge/ { alias /var/www/challenges/; try_files $uri =404; } ...the rest of your config } 重启nginx服务 service nginx reload 自动生成SSL证书 由于Let's Encrypt的证书只有90天的有效期，需要使用系统每个月生成一次。编辑renew_cert.sh文件 以下是v1版，兼容性差点 #!/usr/bin/sh python /etc/ssl/letsencrypt/acme_tiny.py --account-key /etc/ssl/letsencrypt/account.key --csr /etc/ssl/letsencrypt/domain.csr --acme-dir /var/www/challenges/ &gt; /etc/ssl/letsencrypt/signed.crt || exit wget -O - https://letsencrypt.org/certs/lets-encrypt-x1-cross-signed.pem &gt; /etc/ssl/letsencrypt/intermediate.pem cat /etc/ssl/letsencrypt/signed.crt /etc/ssl/letsencrypt/intermediate.pem &gt; /etc/ssl/letsencrypt/chained.pem service nginx reload 建议使用v3版 #!/usr/bin/sh python /etc/ssl/letsencrypt/acme_tiny.py --account-key /etc/ssl/letsencrypt/account.key --csr /etc/ssl/letsencrypt/domain.csr --acme-dir /var/www/challenges/ &gt; /etc/ssl/letsencrypt/signed.crt || exit wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; /etc/ssl/letsencrypt/intermediate.pem cat /etc/ssl/letsencrypt/signed.crt /etc/ssl/letsencrypt/intermediate.pem &gt; /etc/ssl/letsencrypt/chained.pem service nginx reload 添加可执行权限 chmod +x renew_cert.sh 编辑crontab文件 crontab -e 加入如下内容 0 0 1 * * /etc/ssl/letsencrypt/renew_cert.sh 2&gt;&gt; /var/log/acme_tiny.log 重启crontab服务 service crond restart 测试一下SSL质量 网址：https://www.ssllabs.com/ssltest/ ","link":"https://blog.coolcode.dev/post/20160213-29-使用acme-tiny工具生成Let's Encrypt的免费SSL证书/"},{"title":"Google Java编程风格指南中文版","content":"作者：Hawstein 前言 这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。 与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。 1.1 术语说明 在本文档中，除非另有说明： 术语class可表示一个普通类，枚举类，接口或是annotation类型(@interface) 术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。 其他的术语说明会偶尔在后面的文档出现。 1.2 指南说明 本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。 源文件基础 2.1 文件名 源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。 2.2 文件编码：UTF-8 源文件编码格式为UTF-8。 2.3 特殊字符 2.3.1 空白字符 除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着： 所有其它字符串中的空白字符都要进行转义。 制表符不用于缩进。 2.3.2 特殊转义序列 对于具有特殊转义序列的任何字符(\\b, \\t, \\n, \\f, \\r, \\“, \\‘及)，我们使用它的转义序列，而不是相应的八进制(比如\\012)或Unicode(比如\\u000a)转义。 2.3.3 非ASCII字符 对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\\u221e)，取决于哪个能让代码更易于阅读和理解。 Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。 例如： String unitAbbrev = &quot;μs&quot;; // 赞，即使没有注释也非常清晰 String unitAbbrev = &quot;\\u03bcs&quot;; // &quot;μs&quot; //允许，但没有理由要这样做 String unitAbbrev = &quot;\\u03bcs&quot;; // Greek letter mu, &quot;s&quot; // 允许，但这样做显得笨拙还容易出错 String unitAbbrev = &quot;\\u03bcs&quot;; // 很糟，读者根本看不出这是什么 return '\\ufeff' + content; // byte order mark // Good，对于非打印字符，使用转义，并在必要时写上注释 Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话) 源文件结构 一个源文件包含(按顺序地)： 许可证或版权信息(如有需要) package语句 import语句 一个顶级类(只有一个) 以上每个部分之间用一个空行隔开。 3.1 许可证或版权信息 如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 3.2 package语句 package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里) 3.3 import语句 3.3.1 import不要使用通配符 即，不要出现类似这样的import语句：import java.util.*; 3.3.2 不要换行 import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行) 3.3.3 顺序和间距 import语句可分为以下几组，按照这个顺序，每组由一个空行分隔： 所有的静态导入独立成组 com.google imports(仅当这个源文件是在com.google包下) 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun java imports javax imports 组内不空行，按字典序排列。 3.4 类声明 3.4.1 只有一个顶级类声明 每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。 例外：package-info.java，该文件中可没有package-info类。 3.4.2 类成员顺序 类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。 3.4.2.1 重载：永不分离 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 格式 术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。 4.1 大括号 4.1.1 使用大括号(即使是可选的) 大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。 4.1.2 非空块：K &amp; R 风格 对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets): 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 示例： return new MyClass() { @Override public void method() { if (condition()) { try { something(); } catch (ProblemException e) { recover(); } } } }; 4.8.1节给出了enum类的一些例外。 4.1.3 空块：可以用简洁版本 一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。 示例： void doNothing() {} 4.2 块缩进：2个空格 每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例) 4.3 一行一个语句 每个语句后要换行。 4.4 列限制：80或100 一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。 例外： 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。 package和import语句(见3.2节和3.3节)。 注释中那些可能被剪切并粘贴到shell中的命令行。 4.5 自动换行 术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。 我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。 Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧) 4.5.1 从哪里断开 自动换行的基本准则是：更倾向于在更高的语法级别处断开。 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&amp;（&lt;T extends Foo &amp; Bar&gt;)，catch块中的管道符号(catch (FooException | BarException e) 如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。 方法名或构造函数名与左括号留在同一行。 逗号(,)与其前面的内容留在同一行。 4.5.2 自动换行时缩进至少+4个空格 自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。 当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。 第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。 4.6 空白 4.6.1 垂直空白 以下情况需要使用一个空行： 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。在函数体内，语句的逻辑分组间使用空行。 例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。 要满足本文档中其他节的空行要求(比如3.3节：import语句) 多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。 4.6.2 水平空白 除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方： 分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。 分隔任何保留字与其前面的右大括号(})(如else, catch)。 在任何左大括号前({)，两个例外： @SomeAnnotation({a, b})(不使用空格)。 String[][] x = foo;(大括号间没有空格，见下面的Note)。 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号： 类型界限中的&amp;(&lt;T extends Foo &amp; Bar&gt;)。 catch块中的管道符号(catch (FooException | BarException e)。 foreach语句中的分号。 在, : ;及右括号())后 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。 类型和变量之间：List list。 数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。 Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。 4.6.3 水平对齐：不做要求 术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。 这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。 以下示例先展示未对齐的代码，然后是对齐的代码： private int x; // this is fine private Color color; // this too private int x; // permitted, but future edits private Color color; // may leave it unaligned Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对&gt; 齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多&gt; &gt; 的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。 4.7 用小括号来限定组：推荐 除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。 4.8 具体结构 4.8.1 枚举类 枚举常量间用逗号隔开，换行可选。 没有方法和文档的枚举类可写成数组初始化的格式： private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 4.8.2 变量声明 4.8.2.1 每次只声明一个变量 不要使用组合声明，比如int a, b;。 4.8.2.2 需要时才声明，并尽快进行初始化 不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 4.8.3 数组 4.8.3.1 数组初始化：可写成块状结构 数组初始化可以写成块状结构，比如，下面的写法都是OK的： new int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] { 0, 1, 2, 3 } new int[] {0, 1, 2, 3} 4.8.3.2 非C风格的数组声明 中括号是类型的一部分：String[] args， 而非String args[]。 4.8.4 switch语句 术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 4.8.4.1 缩进 与其它块状结构一致，switch块中的内容缩进为2个空格。 每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。 4.8.4.2 Fall-through：注释 在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例： switch (input) { case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input); } 4.8.4.3 default的情况要写出来 每个switch语句都包含一个default语句组，即使它什么代码也不包含。 4.8.5 注解(Annotations) 注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如： @Override @Nullable public String getNameIfPresent() { ... } 例外：单个的注解可以和签名的第一行出现在同一行。例如： @Override public int hashCode() { ... } 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如： @Partial @Mock DataLoader loader; 参数和局部变量注解没有特定规则。 4.8.6 注释 4.8.6.1 块注释风格 块注释与其周围的代码在同一缩进级别。它们可以是/* ... /风格，也可以是// ...风格。对于多行的/ ... /注释，后续行必须从开始， 并且与前一行的*对齐。以下示例注释都是OK的。 /* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 注释不要封闭在由星号或其它字符绘制的框架里。 Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/* ... */。 4.8.7 Modifiers 类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。 public protected private abstract static final transient volatile synchronized native strictfp 命名约定 5.1 对所有标识符都通用的规则 标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\\w+。 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。 5.2 标识符类型的规则 5.2.1 包名 包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 5.2.2 类名 类名都以UpperCamelCase风格编写。 类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。 测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。 5.2.3 方法名 方法名都以lowerCamelCase风格编写。 方法名通常是动词或动词短语。 下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test_，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。 5.2.4 常量名 常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？ 每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。 // Constants static final int NUMBER = 5; static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;); static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable static final SomeMutableType[] EMPTY_ARRAY = {}; enum SomeEnum { ENUM_CONSTANT } // Not constants static String nonFinal = &quot;non-final&quot;; final String nonStatic = &quot;non-static&quot;; static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;(); static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable); static final Logger logger = Logger.getLogger(MyClass.getName()); static final String[] nonEmptyArray = {&quot;these&quot;, &quot;can&quot;, &quot;change&quot;}; 这些名字通常是名词或名词短语。 5.2.5 非常量字段名 非常量字段名以lowerCamelCase风格编写。 这些名字通常是名词或名词短语。 5.2.6 参数名 参数名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 5.2.7 局部变量名 局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 5.2.8 类型变量名 类型变量可用以下两种风格之一进行命名： 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。 5.3 驼峰式命名法(CamelCase) 驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如&quot;IPv6&quot;或&quot;iOS&quot;)。Google指定了以下的转换方案。 名字从散文形式(prose form)开始: 把短语转换为纯ASCII码，并且移除任何单引号。例如：&quot;Müller’s algorithm&quot;将变成&quot;Muellers algorithm&quot;。 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如&quot;AdWords&quot;将分割成&quot;ad words&quot;)。 需要注意的是&quot;iOS&quot;并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：最后将所有的单词连接起来得到一个标识符。 每个单词的第一个字母都大写，来得到大驼峰式命名。 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。 示例： Prose form Correct Incorrect ------------------------------------------------------------------ \"XML HTTP request\" XmlHttpRequest XMLHTTPRequest \"new customer ID\" newCustomerId newCustomerID \"inner stopwatch\" innerStopwatch innerStopWatch \"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS \"YouTube importer\" YouTubeImporter YoutubeImporter* 加星号处表示可以，但不推荐。 Note：在英语中，某些带有连字符的单词形式不唯一。例如：&quot;nonempty&quot;和&quot;non-empty&quot;都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。 编程实践 6.1 @Override：能用则用 只要是合法的，就把@Override注解给用上。 6.2 捕获的异常：不能忽视 除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。 try { int i = Integer.parseInt(response); return handleNumericResponse(i); } catch (NumberFormatException ok) { // it's not numeric; that's fine, just continue } return handleTextResponse(response); 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 try { emptyStack.pop(); fail(); } catch (NoSuchElementException expected) { } 6.3 静态成员：使用类进行调用 使用类名调用静态的类成员，而不是具体某个对象或表达式。 Foo aFoo = ...; Foo.aStaticMethod(); // good aFoo.aStaticMethod(); // bad somethingThatYieldsAFoo().aStaticMethod(); // very bad 6.4 Finalizers: 禁用 极少会去重载Object.finalize。 Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。 Javadoc 7.1 格式 7.1.1 一般形式 Javadoc块的基本格式如下所示： /** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } 或者是以下单行形式： /** An especially short bit of Javadoc. */ 基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。 7.1.2 段落 空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签，并且它和第一个单词间没有空格。 7.1.3 Javadoc标记 标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 7.2 摘要片段 每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。 这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或This method returns...开头, 它也不会是一个完整的祈使句，如Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。 Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID /，这是不正确的。它应该写成/* Returns the customer ID. */。 7.3 哪里需要使用Javadoc 至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 7.3.1 例外：不言自明的方法 对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 7.3.2 例外：重载 如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 7.3.3 可选的Javadoc 对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。 后记 本文档翻译自Google Java Style， 作者@Hawstein。 ","link":"https://blog.coolcode.dev/post/20160129-28-Google Java编程风格指南中文版/"},{"title":"防止重复发送 Ajax 请求的解决方案","content":"问题描述 在页面中有多个按钮，点击该按钮可以异步的去服务端读取数据，然后在前端将数据展示出来。 每个按钮点击请求的页面都是同一个，但是请求的参数不同，所以返回的内容就不同。 在连续点击多个按钮的时候就会发出多个异步请求。那么根据请求返回的快慢(因为不同按钮参数不同，返回内容不同，所以会有快慢之分），数据会依次的展示出来，那么就会出现一个先点击的按钮，由于他请求的数据量比较大，导致数据被后显示出来。 问题解决 解决这种问题有两种方式： 当连续进行多个请求，并且请求的url地址相同时。放弃前面的所有请求，只执行最后一次请求。 当连续进行多个请求，并且请求的url地址相同时。放弃后面的所有请求，只执行第一次请求。 解决方案 一、将ajax请求的async设置为false $.ajax({ async: false, type : &quot;POST&quot;, url : defaultPostData.url, dataType : 'json', success : function(data) { } }); async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 二、利用jquery ajaxPrefilter中断请求 由于第一种方案只是一种曲线救国的方式，其实没能真正的解决上面的问题。所以，建议使用这种方式。 var pendingRequests = {}; $.ajaxPrefilter(function( options, originalOptions, jqXHR ) { var key = options.url; console.log(key); if (!pendingRequests[key]) { pendingRequests[key] = jqXHR; }else{ //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 } var complete = options.complete; options.complete = function(jqXHR, textStatus) { pendingRequests[key] = null; if ($.isFunction(complete)) { complete.apply(this, arguments); } }; }); Prefilters是一个预过滤器，在每个请求之前被发送和$.ajax()处理它们前处理。 options 是请求的选项 originalOptions 值作为提供给Ajax方法未经修改的选项，因此，没有ajaxSettings设置中的默认值 jqXHR 是请求的jqXHR对象 以上内容的核心思想是维护一个队列，发送请求时，将请求加入队列，请求响应后，从队列中清除，这就保证了在任一时刻只能有一个同样的请求发送. 局限性：仅仅是前台防止jquery的ajax请求。对于非jquery的ajax请求，不起作用。因为使用的是jquery的ajaxPreFilter函数，仅仅对jquery的ajax请求有作用。 调用abort后jquery会执行error的方法，抛出abort的异常信息。可以使用以下方式区分出该类型的异常。 var ajax = $.ajax({ 'error':function(jqXHR, textStatus, errorThrown){ if(errorThrown != 'abort'){ //ajax被调用abort后执行的方法 alert('您的ajax方法被停止了'); } } }) Demo 按钮每次点击都会向后端发送请求，下面的demo实现了多次点击按钮之后，只保证最后一次点击的请求能够成功。 &lt;button id=&quot;button1&quot;&gt;button1&lt;/button&gt; &lt;button id=&quot;button2&quot;&gt;button2&lt;/button&gt; &lt;button id=&quot;button3&quot;&gt;button3&lt;/button&gt; &lt;script&gt; var pendingRequests = {}; jQuery.ajaxPrefilter(function( options, originalOptions, jqXHR ) { var key = options.url; console.log(key); if (!pendingRequests[key]) { pendingRequests[key] = jqXHR; }else{ //jqXHR.abort(); //放弃后触发的提交 pendingRequests[key].abort(); // 放弃先触发的提交 } var complete = options.complete; options.complete = function(jqXHR, textStatus) { pendingRequests[key] = null; if (jQuery.isFunction(complete)) { complete.apply(this, arguments); } }; }); &lt;!-- 异步加载应用列表开始 --&gt; $(&quot;#button1&quot;).live(&quot;click&quot;, function() { $.ajax('config/ajax/appinfoListFetcher.json', { type:'POST', data: {param1:value1, param2:value2, }, success: function(res){ //后端数据回写到页面中 }, error:function(jqXHR, textStatus, errorThrown){ if(errorThrown != 'abort'){ alert('应用加载失败！'); } } }); &lt;!-- 异步加载应用列表结束 --&gt; }); &lt;/script&gt; 转自：http://www.hollischuang.com/archives/931 ","link":"https://blog.coolcode.dev/post/20160114-25-防止重复发送 Ajax 请求的解决方案/"},{"title":"centos6.4源码安装git","content":"需要给 CentOS 下载安装编译工具。 yum groupinstall &quot;Development Tools&quot; 安装一些 git 构建或执行时需要的其他依赖。 yum install zlib-devel perl-ExtUtils-MakeMaker asciidoc xmlto openssl-devel 下载 git 最新版本的源代码 wget -O git.zip https://github.com/git/git/archive/master.zip 解压源文件 unzip git.zip cd git-master 安装git autoconf ./configure make &amp;&amp; make install ln -s /usr/local/bin/git /usr/bin/ 检查 git 版本 git --version ","link":"https://blog.coolcode.dev/post/20160112-24-centos6.4源码安装git/"},{"title":"centos 6.4升级默认python2.6到2.7","content":"官网下载 wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tar.xz 解压 xxx.tar.xz的解压方式，xz -d xxx得到xxx.tar包，还得使用tar xvf xxx解压。xxx.tar.xz包的压缩过程是tar cvf xxx.tar xxx/和 xz -z xxx.tar.xz xz -d Python-2.7.11.tar.xz tar xvf Python-2.7.11.tar 安装 ./configure make make install 修改系统默认版本 cd /usr/bin/ mv python python2.6.6 ln -s /usr/local/bin/python2.7 python 查看python版本，显示版本升级成功。 # python -V Python 2.7.11 修改yum命令依赖python2.6版本 打开yum脚本文件：vim /usr/bin/yum 把 #!/usr/bin/python 修改为 #!/usr/bin/python2.6 ","link":"https://blog.coolcode.dev/post/20160112-23-centos 6.4升级默认python2.6到2.7/"},{"title":"PHP小版本跨度使用config.nice编译升级方法","content":"PHP在编译的时候要用./configure来编译，有很多enable、with等条件，升级的时候要记得原来的./configure条件。如果版本跨越不大，可以不用这个方法。我说说PHP 5.4.16升级到PHP 5.4.17的示例。 在安装PHP 5.4.16的时候，原来的包PHP 5.4.16一定不要删除，当你编译完成后，会在php-5.4.16根目录留下config.nice文件。 升级到PHP 5.4.17： wget http://jp1.php.net/distributions/php-5.4.17.tar.gz tar zxf php-5.4.17.tar.gz cp php-5.4.16/config.nice php-5.4.17 cd php-5.4.17 ./config.nice make &amp;&amp; make install 最后重启PHP即可。 转自：http://www.lvtao.net/config/php_config_nice.html ","link":"https://blog.coolcode.dev/post/20160110-22-PHP小版本跨度使用config.nice编译升级方法/"},{"title":"Gulp 4 入门指南","content":"原文地址：http://www.ociweb.com/resources/publications/sett/gulp-4/ 介绍 gulp是一个基于JavaScript的构建工具，它主要用于web部署任务的自动化执行。gulp可以自动化完成你通过Node.js做的任何事。由于Node.js可以执行shell命令，所以gulp几乎可以自动化所有任务。但在实际使用中，gulp主要用于web开发中。 gulp与Grunt gulp的主要竞争对手是Grunt，它和gulp一样是免费和开源的。其他不怎么火的竞争者有：Broccoli，Brunch，Cake和Jake。 配置方法是gulp和Grunt的主要差异之一。它们都通过一个JavaScript文件进行配置，gulp将其命名为 gulpfile.js，Grunt将其命名为Gruntfile.js。gulp通过调用不同的函数（gulp.taks，gulp.watch）完成 配置，而grunt则通过传递一个字面量对象（{... ：...}）参数给grunt.initConfig函数来完成配置。 gulp对比Grunt的优势之一是，gulp的运行速度相比Grunt更快。这归功于它使用了stream。对比两者执行连续任务的方式，Grunt执行连续任务通过创建大量的临时文件**（临时文件作为步骤i的输出以及步骤i+1的输入）**。gulp使用stream则允许我们更早的开始接下去的任务，只要stream中存在数据即可开始，而非必须等待整个文件被写完。 gulp与Node.js 如果你希望使用gulp，那么必须安装Node.js。当然，它同样可以在io.js上运行（io.js是Node.js的一个分支，它使用了更新 版本的v8 javascript引擎，并且更新的更频繁）。就如同Node.js，gulp可以在多种平台下使用，例如windows，mac osx和其他unix系的操作系统。 在gulp中，我们同样可以使用es6中的特性（通过在Node.js或io.js，使用--harmony参数开启es6中的特性）， 在*nix环境下，你需要这么做： 创建一个别名alias gulp6='node --harmony $(which gulp)'(what is $() ?, what is which?)，你也可以将这行代码放在.bashrc中，这样每次你打开终端时它都将生效。完成这些，你就可以使用gulp6命令代替gulp命令，开始享受es6带来的新特性。 在windows环境下： 你可以试着使用doskey命令来做类似的事。 本文的某些例子中将使用es6的一项新特性，箭头函数表达式。这个特性允许我们使用一种更简洁的方式来书写匿名函数，并且它还有其他的优点（详情可见：Arrow functions MDN）。对于本文，你只需知道function () { return expression; }在es6中等价于() =&gt; expression。 gulp插件简介 gulp的一大优势是大量有用的插件，它们能够帮助我们完成各种任务。截止到2015.5.25，已经有1711个gulp插件可供使用。你可以试着在*nix系统中使用npm search gulpplugin | wc-l命令来查看最新的插件数目。 我们可以使用gulp来完成以下常见的任务： 检查html，css，javascript和json文件的语法。 将es6 javascript代码编译为es5（通过使用babel，traceur或者typescript）。 运行单元测试和端到端测试。 合并和压缩css，javascript文件。 通过http来提供静态文件服务。 执行shell命令。 监视特定文件或者文件类型的改变，当监察到改变后运行特定任务。 当文件改变后刷新浏览器（livereload）。 关于gulp插件，下文将更详细的讲述。 在我写这篇文章时，gulp最新的稳定版本为3。本文介绍的目标是新的开发版本4。版本4并不向后兼容版本3。如果你希望使用gulp4，那么你需要修改gulpfile.js。当然，大部分面向gulp3的插件仍然可在gulp4正常使用。 这篇文章中，如果你使用的是windows，那你需要将terminal替换为Command Prompt。 安装gulp 在终端键入npm install -g gulp，将安装最新，稳定的版本。如果你希望在gulp4成为稳定版之前就安装它，那么执行以下指令： 2. 打开终端。 4. 确定已正确安装git。 6. 如果之前安装过gulp，使用npm uninstall -g gulp命令来卸载它。 8. 使用npm install -g gulpjs/gulp-cli#4.0命令来安装gulp 4。 如果你希望现在就在你的项目中使用gulp4，那么执行以下命令： 2. 打开终端。 4. 进入到你项目的顶层目录。 6. 使用npm init命令来新建package.json文件，回答新建过程中遇到的问题。 8. 本地安装gulp并且将它作为一个依赖添加到package.json中，命令如下：npm install gulp --save-dev 10. 如果之前已安装非4版本的gulp，那么使用npm uninstall gulp指令卸载它。 12. 本地安装gulp4并且将它作为一个依赖添加到package.json中，命令如下：npm install gulpjs/gulp.git#4.0 --save-dev。（原文命令npm install gulpjs/gulp-cli#4.0 --save-dev，实验后并不能安装本地gulp4.0） 14. 创建gulpfile.js npm install的--save-dev参数将在package.json中添加一个开发依赖。这使团队内的其他开发者能够通过使用npm install命令来安装整个项目的依赖。 运行gulp 在尝试运行定义在gulpfile.js内的gulp任务之前，进入到项目目录的根目录或其子目录内。 键入gulp --help或者gulp -h来获取基本的帮助信息。 键入gulp --version或者gulp -v来查看本机安装的gulp的版本。它将显示全局安装和基于项目本地安装的gulp的版本。 键入gulp --tasks或者gulp -T来查看gulpfile.js中定义的所有任务。这将输出一个任务依赖树。如果你希望以平铺的形式查看定义的任务列表，键入gulp --tasks-simple。 键入gulp --verify来检查是否依赖了被列入黑名单中的插件。这将检查列在package.json文件中的依赖。（gulp3.9中没有该命令?） 键入gulp [options] task1 task2...来运行定义在gulpfile.js中的任务。除了任 务名外，我们还可以输入一些可选选项，但是通常来说我们不会使用它们。当我们同时输入了多个任务名，它们将被并行运行。如果希望它们能够串行的运行，那么 在gulpfile.js中定义一个新任务，在该任务内依次执行它们，然后单独在命令行中运行那个新任务。如果没有指定任务名，那么default任务将 运行，之后我们将看到如何定义一个默认任务。如果不指定具体的任务，并且没有定义default任务，那会显示一条错误信息。 大部分任务运行结束后gulp将退出。某些任务例如connect（用于提供http静态资源服务）和watch（用于监视文件是否有改变）将会一直运行直到任务被人为取消（或者出错退出），gulp将不会自动退出。你可以使用ctrl-c来退出任务并结束gulp。 gulp插件 gulp有大量的插件可用，下列是我推荐的一些优秀插件： gulp-babel -将es6(JavaScript)编译为es5(JavaScript)。 gulp-changed -过滤掉比目标文件旧的文件（只处理有更新的文件）。 gulp-concat -合并css和javascript文件。 gulp-csslint -检验css文件正确性。 gulp-eslint -使用eslint检验javascript正确性。 gulp-jasmine -运行jasmine测试。 gulp-jshint -使用jshint检验javascript正确性。 gulp-jscs -使用jscs检查javascript代码风格。 gulp-less -将less文件编译为css。 gulp-livereload -当调用livereload方法时，刷新监听的浏览器。 gulp-plumber -允许gulp在发生错误之后继续运行。 gulp-sourcemaps -产生允许调试的sourcemap文件，用来调试被编译过的javascript文件。 gulp-uglify -压缩javascript文件。 gulp-usemin -将html文件中css，js文件的路径替换为其min版本。 gulp-watch -监视文件是否被修改并且在我们修改文件后执行指定任务。 此外，我们经常使用npm的del模块来删除指定的目录和文件。 你可以通过访问http://gulpjs.com/plugins来搜索gulp插件。该站将列出那些带有gulpplugin关键词，且被发布到npm的插件，通过点击插件名链接可以直接访问插件文档。另一个搜索插件的方法是使用npm search命令。比如，可以键入npm search gulpplugin lint来搜索有linting功能的插件。 我们可以键入npm install plugin-name --save-dev来安装一个插件。这将安装插件到项目的node_modules目录。一旦插件安装完成，就可以修改gulpfile.js来require插件并且在一个或多个任务使用它。比如，var foo = require('gulp-foo'); 一个更好的require插件的方法是使用gulp-load-plugins插件，它为我们提供了更好的require功能。这让我们不必为添加 每个插件使用require。gulp-load-plugins读取package.json中那些名字以gulp-开始的依赖，并返回一个对象，对象 的属性是依赖的名字。gulp-load-plugins有lazy load特性，它直到插件被使用时才会读取插件，而不用到的插件不会被读取。 var pi = require('gulp-load-plugins')(); //我们可以在任务的定义内使用pi.name来引用插件。 gulp方法（下列API皆为gulp4.0版本） gulp和undertaker类中定义了gulp所提供的方法。 gulp类提供了src，dest和watch方法。它定义在gulp的github repo中的顶层文件index.js中（现在的地址为https://github.com/gulpjs/gulp/tree/4.0）。这个类继承于undertaker类。 undertaker类提供了task，series，parallel，get，set，tree和registry方法。它定义在undertaker的github repo中的顶层文件index.js中（https://github.com/phated/undertaker）。undertaker类继承于node核心类eventemitter（https://nodejs.org/api/events.html）。 如果只是为了使用gulp，并不一定要了解这些继承关系。但是理解这些关系将有助于我们理解如何使用其中某些方法。 gulp使用的另一个关键的npm模块是vinyl-fs。vinyl-fs使用vinyl对象来存储用于描述文件的metadata。vinyl 适配器提供了通过stream来访问vinyl对象内容的方法。源stream产生文件对象，目标stream使用这些文件对象。更具体的可以参见https://github.com/wearefractal/vinyl-fs，https://github.com/wearefractal/vinyl和https://medium.com/@contrahacks/gulp-3828e8126466。 下面这行代码可以帮助我们获取一个gulp对象： var gulp = require('gulp'); 这个对象支持gulp类，undertaker类和eventemitter类中定义的所有方法。 在介绍具体的方法之前，我们需要先简单理解下通配符。gulp中的许多方法接受通配符参数。这可以是一个字符串或者一个由字符串组成的数组。字符串可以包含通配符。底层的实现由npm模块node-glob提供。更详细的语法参见“glob primer”。基本语法包括： **？**代表任一字符。 *代表0个或多个任意字符。 ** 在路径中表示任意数目的目录。 src方法 src方法提供了一个vinyl对象组成的stream，这些stream将传递给插件使用。它接受一个通配符表达式和一个选项对象（可选）。通配符表达式指明了将要处理的输入文件。选项则将传递给glob模块。详情请参见https://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpsrcglobs-options和https://github.com/isaacs/node-glob。 dest方法 dest方法接受输送来的stream数据并且将它输出至文件。所有流向它的数据都存在备份**（原文re-emmited）**，这允许我们多次调用dest方法来将结果输出至多个文件。他接受一个目标路径参数和一个选项对象（可选）。目标路径参数指定了输出文件或者目录的路径。对于选项的详细介绍，请参见https://github.com/gulpjs/gulp/blob/master/docs/API.md#gulpdestpath-options。 watch方法 watch方法将监视文件并且当它们被改变时调用指定任务。它接受一个通配符表达式，一个选项对象（可选）和一个方法。通配符表达式指定了需要监视的文件。这个方法通过npm模块gaze来实现。详情请参见https://github.com/shama/gaze。 task方法 task方法定义了一个任务。它接受一个任务名字符串和一个方法。当任务开始运行，这个方法也将开始运行。方法可以是匿名函数或者声明在任意位置的函数。如果没有传入方法对象，将返回先前定义的任务方法。 series方法 series方法将返回一个函数。当你调用这个函数时，它将串行执行你定义在series方法中的任务。它接受任意数目的参数，参数可以是任务名或函数。因为它返回一个函数，它可以作为参数使用在其他方法中（如task方法）。 parallel方法 parallel方法将返回一个函数，当你调用这个函数时，他将并行执行你定义在parallel方法中的任务。它接受任意数目的参数，参数可以是任务名和函数。因为它返回一个函数，它可以作为参数使用在其他方法中（如task方法）。 下列所述的undertaker类中的方法通常不会直接使用在gulpfile.js中。 get方法 get方法将返回一个和传入的任务名相关的函数，它接受一个任务名作为参数。 set方法 set方法设置或者改变和传入的任务名相关的函数。它接受一个任务名和一个函数作为参数，如果该任务已经定义了任务执行函数，那么该函数将被替换。 tree方法 tree方法返回一个数组，该数组将包括已经定义的任务名字符串。它接受一个额外参数对象。如果deep参数设置为true，那么返回的数组还将包括每个任务的依赖关系。这个方法等于在命令行使用gulp --tasks或者gulp --tasks-simple。 registry方法 registry方法获取或者设置任务名和任务执行函数的映射。 定义gulp任务 因为gulp运行在Node.js上，gulpfile.js中可以包含任何Node.js可以处理的代码。这代表所有的Node.js核心模块和npm模块都可以使用。 下面是一个简单的定义gulp任务的例子： var gulp = require('gulp'); gulp.task('hello', function () { console.log('Hello, World!'); }); 下面是这个例子在es6中的实现： let gulp = require('gulp'); gulp.task('hello', () =&gt; console.log('Hello, World!')); 然后键入gulp hello，你将会看到屏幕上打印出'Hello,World!'。 以下三种形式都将定义一个gulp任务： gulp.task(name, function () { ... }); gulp.task(name, gulp.series(...)); gulp.task(name, gulp.parallel(...)); 一个gulp任务通常来说会读取特定的文件，对文件内容采取一个或多个的操作，然后生成一个或多个输出文件。下面是一个普通的gulp任务： gulp.task(name, function () { return gulp.src(srcPath). pipe(somePluginFn()). pipe(anotherPluginFn()). pipe(gulp.dest(destPath)); }); 在es6中，我们也可以这么写： gulp.task(name, () =&gt; gulp.src(srcPath). pipe(somePluginFn()). pipe(anotherPluginFn()). pipe(gulp.dest(destPath))); 使用gulp提供静态资源服务 有许多npm模块通过http协议来向外提供静态文件。一个常见选择是connect。安装必要模块的命令如下： npm install connect --save npm install serve-static -save 下面是一个gulp任务从项目目录顶层提供静态文件的例子： var connect = require('connect'); var http = require('http'); // a Node.js core module var serveStatic = require('serveStatic'); gulp.task('connect', function () { var app = connect(); app.use(serveStatic(__dirname)); var port = 8080; http.createServer(app).listen(port); }); __dirname是一个Node.js全局变量，它存放了当前目录的路径。如果在该目录内有一个index.html文件，那么我们可以通过在浏览器地址栏键入httpL//localhost:8080来访问它。 如果要运行这个任务，键入gulp connect 监听文件 gulp可以监听文件的改变或新文件的创建。但如果是gulpfile.js本身被改变了，那么必须重启gulp来使用被修改过的gulpfile.js。 下面是一个使用gulp来监听less文件改变的例子。当gulp到改变后，它将运行less和csslint任务。 gulp.task('watch', function () { gulp.watch('styles/*.less', gulp.series('less', 'csslint')); }) Live Reload 不仅如此，gulp甚至可以让浏览器自动刷新。这个功能对于那些浏览器读取的文件很有用，比如html，css，javascript文件等。现在，有许多gulp插件支持这个功能。最常见的是gulp-livereload。这个插件最好与chrome协作使用，并且需要安装livereload chrome插件。如果你希望安装该插件，访问https://chrome.google.com/webstore/category/apps然后搜索livereload。 你可以按下列步骤来使用该插件： 2. 安装gulp-livereload插件。 4. 添加script元素至html文件：。 6. 在watch任务内调用livereload.listen()。 8. 在需要触发刷新时调用livereload()。 下面的gulpfile.js作为示例，展示了上述所述的最后两步。他定义了许多gulp任务，这些在我们日常的web应用中都十分常见并且有用。 gulpfile.js示例 var connect = require('connect'); var del = require('del'); var gulp = require('gulp'); var http = require('http'); var pi = require('gulp-load-plugins')(); var serveStatic = require('serve-static'); var paths = { build: 'build', css: 'build/**/*.css', html: ['index.html', 'src/**/*.html'], js: ['src/**/*.js'], jsPlusTests: ['src/**/*.js', 'test/**/*.js'], less: 'src/**/*.less', test: 'build/**/*-test.js' }; // This just demonstrates the simplest possible task. gulp.task('hello', function () { console.log('Hello, World!')); }); // This deletes all generated files. // In tasks that do something asynchronously, the function // passed to task should take a callback function and // invoke it when the asynchronous action completes. // This is how gulp knows when the task has completed. gulp.task('clean', function (cb) { del(paths.build, cb); }); // This starts a simple HTTP file server. gulp.task('connect', function () { var app = connect(); app.use(serveStatic(__dirname)); http.createServer(app).listen(1919); }); // This validates all CSS files. // In this example, the CSS files are generated from LESS files. gulp.task('csslint', function () { return gulp.src(paths.css). pipe(pi.csslint({ids: false})). pipe(pi.csslint.reporter()); }); // This validates JavaScript files using ESLint. gulp.task('eslint', function () { return gulp.src(paths.jsPlusTests). pipe(pi.changed(paths.build)). pipe(pi.eslint({ envs: ['browser', 'es6', 'node'], rules: { curly: [2, 'multi-line'], indent: [2, 2] } })). pipe(pi.eslint.format()); }); // This is used by the &quot;watch&quot; task to // reload the browser when an HTML file is modified. gulp.task('html', function () { return gulp.src(paths.html). pipe(pi.livereload()); }); // This validates JavaScript files using JSHint. gulp.task('jshint', function () { return gulp.src(paths.jsPlusTests). pipe(pi.changed(paths.build)). pipe(pi.jshint()). pipe(pi.jshint.reporter('default')); }); // This compiles LESS files to CSS files. gulp.task('less', function () { return gulp.src(paths.less). pipe(pi.changed(paths.build)). pipe(pi.less()). pipe(gulp.dest(paths.build)). pipe(pi.livereload()); }); // This compiles ES6 JavaScript files to ES5 JavaScript files. // &quot;transpile&quot; is a term used to describe compiling // one syntax to a different version of itself. // Compiling ES6 code to ES5 fits this description. gulp.task('transpile-dev', function () { return gulp.src(paths.jsPlusTests). pipe(pi.changed(paths.build)). pipe(pi.sourcemaps.init()). pipe(pi.babel()). pipe(pi.sourcemaps.write('.')). pipe(gulp.dest(paths.build)). pipe(pi.livereload()); }); // This does the same as the previous task, but also // concatenates and minimizes the resulting JavaScript files. gulp.task('transpile-prod', function () { return gulp.src(paths.js). pipe(pi.sourcemaps.init()). pipe(pi.babel()). pipe(pi.concat('all.js')). pipe(pi.uglify()). pipe(pi.sourcemaps.write('.')). pipe(gulp.dest(paths.build)); }); // This is not meant to be used directly. // Use the &quot;test&quot; task instead. gulp.task('jasmine', function () { return gulp.src(paths.test). pipe(pi.plumber()). pipe(pi.jasmine()); }); gulp.task('test', gulp.series('transpile-dev', 'jasmine')); // This watches HTML, LESS, and JavaScript files for changes // and processes them when they do. // It also reloads the web browser. gulp.task('watch', function () { pi.livereload.listen(); gulp.watch(paths.html, gulp.series('html')); gulp.watch(paths.less, gulp.series('less', 'csslint')); gulp.watch(paths.jsPlusTests, gulp.series('eslint', 'jshint', 'transpile-dev')); }); // This compiles LESS and ES5 JavaScript files in parallel. gulp.task('build-dev', gulp.parallel('less', 'transpile-dev')); // This does the same as the previous tasks, but also // concatenates and minimizes the resulting JavaScript files. gulp.task('build-prod', gulp.parallel('less', 'transpile-prod')); // This is used when gulp is run without specifying a task. // It runs the &quot;build-dev&quot; task and then // starts the &quot;connect&quot; and &quot;watch&quot; tasks in parallel. // This is the most commonly used task during development. gulp.task('default', gulp.series('build-dev', gulp.parallel('connect', 'watch'))); gulp的通常用法 对于gulpfile.js的常见使用方法可以总结为以下步骤： 打开一个终端，并且进入到项目文件，运行gulp。这将开启本地http服务器并且监视文件的变化。 保持终端是可见的，这样你能观察到最新的输出。 在支持livereload的浏览器中浏览自己编写的程序。 使用编辑器或IDE来编辑代码。 观察gulp在监视过程中是否产生了错误。 观察浏览器的刷新结果。 就这么不停工作下去。 后续 我们都很关心gulp4何时能够代替gulp3成为最新的稳定版本。在2015.1.29，gulp4的主要开发者发推文说“gulp4本可以在 31号问世，但是很不幸，我得了流感，我感觉很不好，所以对不起了伙计们。”。于是在2015.4.28，历时三个月的等待后，我向他问道，“gulp4 有何最新进展嘛？虽然我们现在已经能够使用它，但是我们更希望他能成为一个官方版本。”。令人遗憾的是，我收到的回复十分简单，“没有。”。在 2015.5.19，gulp的主要开发者发推文表示，“他们获得了1000万对于@gulpjs的赞助。”。我希望这表示他们将会继续新版本的开发工作。 总结 gulp是一款十分流行并且功能强大的自动化web部署工具。看起来，它现在已经比Grunt火多了。如果你现在还没在使用gulp，那还等什么？ 转自:https://github.com/baixing/FE-Blog/issues/7 ","link":"https://blog.coolcode.dev/post/20160107-21-Gulp 4 入门指南/"},{"title":"GitHub 风格的 Markdown 语法","content":" Original: GitHub Flavored Markdown - GitHub Help Translated by: @cssmagic 声明：原文版权属于 GitHub。中文翻译部分并非官方文档，仅供参考。 GitHub uses &quot;GitHub Flavored Markdown,&quot; or GFM, across the site--in issues, comments, and pull requests. It differs from standard Markdown (SM) in a few significant ways, and adds some additional functionality. GitHub 全站支持 “GitHub 风格的 Markdown 语法”（简称 GFM），你可以用它来书写 issue、pull request（以下简称 “PR”）和各种评论。它和标准 Markdown 语法（SM）相比，存在一些值得注意的差异，并且增加了一些额外功能。 If you're not already familiar with Markdown, take a look at Markdown Basics. If you'd like to know more about features that are available in issues, comments, and pull request descriptions, such as task lists, read Writing on GitHub. 如果你对 Markdown 还不是很熟悉，可以先看一眼 Markdown 语法基础。如果你想了解在书写 issue、评论和 PR 描述时有哪些技巧（比如任务清单这样的高级功能），你应该读一下 GitHub 上的书写方式。 Differences from traditional Markdown 与传统 Markdown 的差异 Multiple underscores in words 单词中的多个下划线 Where Markdown transforms underscores (_) into italics, GFM ignores underscores in words, like this: Markdown 会把所有成对的下划线（_）转换为斜体，但 GFM 不会处理单词内的那些下划线，比如这些： wow_great_stuff do_this_and_do_that_and_another_thing. This allows code and names with multiple underscores to render properly. To emphasize a portion of a word, use asterisks (). 这样一来，那些采用下划线作为分隔符的代码或名字就可以正确渲染了。如果你确实要把单词中的某一部分设置为斜体，可以使用星号（）。 URL autolinking 链接自动识别 GFM will autolink standard URLs, so if you want to link to a URL (instead of setting link text), you can simply enter the URL and it will be turned into a link to that URL. GFM 会自动为标准的 URL 加上链接，因此，如果你只想链接到一个 URL（而不想设置链接文字），那你直接输入这个 URL 就可以了，它将被自动转换为一个链接。（译注：Email 地址也适用于此特性。） http://example.com becomes 将被渲染为： http://example.com Strikethrough 删除线 GFM adds syntax to create strikethrough text, which is missing from standard Markdown. GFM 增加了删除线语法，补上了标准 Markdown 在这方面的不足。 ~~Mistaken text.~~ becomes 将被渲染为： Mistaken text. Fenced code blocks 围栏式代码块 Standard Markdown converts text with four spaces at the beginning of each line into a code block; GFM also supports fenced blocks. Just wrap your code in ``` (as shown below) and you won't need to indent it by four spaces. Note that although fenced code blocks don't have to be preceded by a blank line—unlike indented code blocks—we recommend placing a blank line before them to make the raw Markdown easier to read. 标准 Markdown 会把每行前面空四格的文本块转换为代码块；GFM 同时还支持围栏式代码块。只要把你的代码块包裹在 ``` 之间就行了（如下所示），你再也不需要通过无休止的缩进来标记代码块了。请注意，虽然围栏式代码块语法并不需要在头部插入空行（缩进式代码块语法是需要的），但我们仍然建议你留出空行，因为这样可以令 Markdown 源码的可读性更好。 Here's an example: `` function test() { console.log(&quot;notice the blank line before this function?&quot;); } `` Keep in mind that, within lists, you must indent non-fenced code blocks eight spaces to render them properly. 请留意，列表中的代码块需要缩进 8 个空格，才会被正确地渲染。 Syntax highlighting 语法着色 Code blocks can be taken a step further by adding syntax highlighting. In your fenced block, add an optional language identifier and we'll run it through syntax highlighting. For example, to syntax highlight Ruby code: 关于代码块的技巧还不止于此，你还可以为代码块指定语法着色效果。在围栏式代码块中，你可以指定一个可选的语言标识符，然后我们就可以为它启用语法着色了。比如说，这样可以为一段 Ruby 代码着色： ``ruby require 'redcarpet' markdown = Redcarpet.new(&quot;Hello World!&quot;) puts markdown.to_html `` We use Linguist to perform language detection and syntax highlighting. You can find out which keywords are valid by perusing the languages YAML file. 我们使用 Linguist 来进行语言识别和语法着色。你可以在 语言 YAML 文件 中查证哪些语言标识符是有效的。 Tables 表格 You can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe |: 把一系列文本精心组织起来，我们甚至可以得到一个表格。我们需要把表头的那一行用一串横杠（-）隔出来，然后把每一列用竖杠（|）隔开： First Header | Second Header ------------- | ------------- Content Cell | Content Cell Content Cell | Content Cell For aesthetic purposes, you can also add extra pipes on the ends: 出于美观的考虑，你也可以在表格的两端都加上竖杠： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | Note that the dashes at the top don't need to match the length of the header text exactly: 请注意，用于分隔列的竖杠并不需要跟表头严格对齐： | Name | Description | | ------------- | ----------- | | Help | Display the help window.| | Close | Closes a window | You can also include inline Markdown such as links, bold, italics, or strikethrough: 同时，你也可以在单元格内使用那些行内 Markdown 语法，比如加链接、加粗、加斜体或加删除线等等： | Name | Description | | ------------- | ----------- | | Help | ~~Display the~~ help window.| | Close | _Closes_ a window | Finally, by including colons : within the header row, you can define text to be left-aligned, right-aligned, or center-aligned: 最后别忘了，给表头下的各段横线加上冒号（:），还可以指定各列文本的对齐方式： | Left-Aligned | Center Aligned | Right Aligned | | :------------ |:---------------:| -----:| | col 3 is | some wordy text | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. 在横线最左侧加冒号表示该列一律左对齐；在横线最右侧加冒号表示该列一律右对齐；在横线两端加冒号表示该列一律居中对齐。 HTML You can use a subset of HTML within your READMEs, issues, and pull requests. 在 README、issue 和 PR 中，你还可以使用有限的一些 HTML 语法。 A full list of our supported tags and attributes can be found in the github/markup repository. 关于可用的标签和属性有哪些，你可以在 github/markup 这个项目中找到一份完整的清单。 Further reading Writing on GitHub 相关阅读 Markdown 语法基础 转自:https://github.com/baixing/FE-Blog/issues/6 ","link":"https://blog.coolcode.dev/post/20160107-20-GitHub 风格的 Markdown 语法/"},{"title":"GitHub 上的书写方式","content":" Original: Writing on GitHub - GitHub Help Translated by: @cssmagic 声明：原文版权属于 GitHub。中文翻译部分并非官方文档，仅供参考。 Issues, comments, and pull request descriptions are written using GitHub Flavored Markdown along with some additional features to make writing content on GitHub easy. 在 issue、评论和 pull request（以下简称 “PR”）的描述中，我们可以用 GitHub 风格的 Markdown 语法 来编写富文本；此外，GitHub 还提供了一些额外的功能，让我们的书写更加方便。 Markup 语法 Newlines 换行 The biggest difference with writing on GitHub is the way we handle linebreaks. With Markdown, you can hard wrap paragraphs of text to have them combine into a single paragraph. We find this causes a huge number of unintentional formatting errors. In comments, GitHub treats newlines in paragraph-like content as real line breaks, which is usually what you intended. GitHub 上的书写方式有一个最大的不同，在于我们改变了处理换行的方式。在原生的 Markdown 语法中，如果我们把一段文本用硬回车打断成多行，它们仍然会被合并为一个连续的段落。但我们发现，这个特性导致了大量非预期的格式化错误。在评论中，GitHub 会把段落内容中的换行视为真正的换行，而这通常正是你所期望的。 The next paragraph contains two phrases separated by a single newline character: 下面这个段落被一个换行符分隔成了两个短语： Roses are red Violets are blue becomes 将被渲染为： Roses are red Violets are blue （译注：注意，只有在评论中才有这种行为。而所谓 “评论”，似乎是指所有非代码提交产生的内容，比如 issue、PR 的内容，以及对 issue、PR、commit 的所有评论等等。在其它场合下，如果需要产生硬回车，需要在行末使用两个空格。） Task lists 任务清单 Lists can be turned into task lists by prefacing list items with [ ] or [x] (incomplete or complete, respectively). 列表可以被转换为 任务清单，只需要为列表项的开头加上 [ ] 或 [x] 即可（分别表示未完成和已完成）。 @mentions, #refs, links, formatting, and tags @mentions, #refs, [links](), **formatting**, and tags are supported list syntax is required (any unordered or ordered list supported) this is a complete item this is an incomplete item 支持 @提到某人、#引用、链接、格式化 和 HTML 标签 支持 @提到某人、#引用、[链接]()、**格式化** 和 HTML 标签 等语法 需要使用列表语法来激活（无序或有序列表均可） 这是一个已完成项目 这是一个未完成项目 Task lists render with checkboxes in all comments and Markdown files. Select or unselect these checkboxes to mark them as complete or incomplete across GitHub. 在所有评论和 Markdown 文件中，任务清单都会渲染出复选框。在 GitHub 站内，这些复选框都可以通过勾选和取消勾选来切换完成状态。 Task lists can be nested to better structure your tasks: 任务清单还可以嵌套，以便更好地组织任务： a bigger project first subtask #1234 follow up subtask #4321 final subtask cc @mention a separate task 一个大工程 第一项子任务 #1234 接下来的子任务 #4321 最后一项子任务 cc @mention 一项单独的任务 Task lists can be nested to arbitrary depths, though we recommend nesting at most once or twice; more complicated tasks should be broken out into separate lists. 任务清单的嵌套层级是没有限制的，不过我们建议你最多只嵌套一层或两层；如果你的任务清单需要嵌套更多的层数，则意味着应该把它分解为多个独立的清单。 References 事件引用 Certain references are auto-linked: 引用特定的事件将会自动创建链接： SHA: a5c3785ed8d6a35868bc169f07e40e889087fd2e User@SHA: jlord@a5c3785ed8d6a35868bc169f07e40e889087fd2e User/Repository@SHA: jlord/sheetsee.js@a5c3785ed8d6a35868bc169f07e40e889087fd2e #Num: #26 GH-Num: GH-26 User#Num: jlord#26 User/Repository#Num: jlord/sheetsee.js#26 becomes 将被渲染为： SHA: a5c3785 User@SHA: jlord@a5c3785 User/Repository@SHA: jlord/sheetsee.js@a5c3785 #Num: #26 GH-Num: GH-26 User#Num: jlord#26 User/Repository#Num: jlord/sheetsee.js#26 Features 便民功能 Quick quoting 快速引用 Typing r on your keyboard lets you reply to the current issue or pull request with a comment. Any text you select within the discussion thread before pressing r will be added to your comment automatically and formatted as a blockquote. 按下键盘的 r 键将为当前的 Issue 或 Pull Request 添加评论。在按下 r 键之前，你在讨论区中选中的任何文本都将自动以一个块级引用的形式插入到你的评论中。 Name and Team @mentions autocomplete @ 提到人名或团队名时的自动补全 Typing an @ symbol will bring up a list of people or teams on a project. The list filters as you type, so once you find the name of the person or team you are looking for, you can use the arrow keys to select it and hit either tab or enter to complete the name. For teams, just enter the @organization/team-name and all members of that team will get subscribed to the issue. 按下 @ 符号将弹出一个列表，列出这个项目相关的人或团队。这个列表会随着你的输入不断匹配筛选，因此一旦你在列表中发现了你要找的人名或团队名，你就可以用方向键来选中它，然后按回车或 tab 键来补全。对于团队来说，只需要输入 @组织名/团队名，那么团队内的所有成员都将收到提醒。 The autocomplete results are restricted to repository collaborators and any other participants on the thread, so it's not a full global search. It uses the same fuzzy filter as the file finder and works for both usernames and full names. 自动补全的匹配范围仅限制在当前仓库的贡献者以及当前讨论的参与者，因此它并不是一个全局性的搜索。它和文件查找器使用相同的模糊筛选算法，并且同时适用于用户名和全名。 Check out the blog posts for more information about @mention autocompletes for users and teams. 详情参见关于 @ 提到 用户 和 团队 时自动补全的博文。 Emoji autocomplete Emoji 表情符号的自动补全 Typing : will bring up a list of suggested emoji. The list will filter as you type, so once you find the emoji you're looking for, press Tab or Enter to complete the highlighted result. For a full list of available emoji, check out emoji-cheat-sheet.com. 按下 : 将会弹出一个表情符号的建议列表。这个列表会随着你的输入不断匹配筛选，因此一旦在列表中发现了你要找的表情符号，你就可以按 tab 或回车键来补全当前高亮的那一项。在 emoji-cheat-sheet.com 可以查阅所有可用的表情符号。 Issue autocompletion Issue 的自动补全 Typing # will bring up a list of suggested Issues and Pull Requests. Type a number or some text to filter the list, then hit either tab or enter to complete the highlighted result. 按下 # 将会弹出一个 issue 和 PR 建议列表。输入数字或文本可以不断筛选这个列表，然后按 tab 或回车键可以补全当前高亮的那一项。 Zen Mode (fullscreen) writing 禅意模式（全屏书写模式） Zen Mode allows you to write markdown in fullscreen mode. You'll find the Zen Mode button on comment, issue, and pull request forms across the site. 禅意模式允许你以全屏模式进行书写。在站内的评论、issue 和 PR 表单中，你都可以找到禅意模式按钮。 Zen Mode button You can also use it when creating and editing files by using the Zen Mode button above the file box. 在创建或编辑文件时，你也可以在文件框顶部找到禅意模式按钮。 Zen Mode comes with both a light and a dark theme. You can change your theme using the switcher at the top right of the window. 禅意模式提供了两种主题可供选择，浅色版和深色版。你可以用窗口右上角的切换按钮来更换当前主题。 Check out the blog post for more information about Zen writing mode. 详情参见 关于禅意模式的博文。 See also Markdown Basics GitHub Flavored Markdown 相关阅读 Markdown 语法基础 GitHub 风格的 Markdown 语法 转自:https://github.com/baixing/FE-Blog/issues/5 ","link":"https://blog.coolcode.dev/post/20160107-19-GitHub 上的书写方式/"},{"title":"如何在 GitHub 正确吐槽","content":"背景 在几年前，百姓网几乎所有项目的开发流程就已经迁到 GitHub 上了。将 GitHub flow 作为日常开发流程，有一个很大的好处，pull request 很自然地成为 code review 的平台——每个人的代码都必须经过 review 之后，才会合并到主干。 因此，各个项目的 pull request 也逐渐成为一座座金矿，新人可以在历史 PR 中汲取经验，高手也常常通过 PR 追查疑难杂症的来龙去脉。而对我这个吐槽狂来说，PR 也是一个非常重要的阵地…… 一个吐槽狂的日常 我叫魔法哥，我是一个吐槽狂。每当我在公司项目中看到不靠谱的代码，总是忍不住一吐为快。我相信，吐槽使人进步，吐槽改变世界。 吐槽很爽，但也有风险。即使某段代码看起来不太对劲，我也要再三确认，因为一旦搞错了，会很没面子。接下来，我会告诉你，我如何安全、优雅、正确地在 GitHub 吐槽别人的代码。 “这行代码是谁写的？” 看到不靠谱的代码，我们的第一反应通常是这个疑问。怨有头债有主，先要弄清楚喷谁。 我厂推荐使用 JetBrains 系列 IDE 来干活（公司出钱买正版），因此这里以 PhpStorm 为例，来还原一下我的工作场景。 对于启用了版本控制的项目，PhpStorm 允许我们查看每一行代码的作者信息。在行号处点击右键，选中 Annotate，即可开启此功能。（图一） 行号栏会扩展出一条作者信息栏，显示出每行代码所属的 commit 版本号、更新日期、作者等信息。当鼠标悬停在此栏时，还会显示每行的详细信息，包括完整的 commit 版本号、精确的更新时间、commit 的标题等。（图二） “它是怎么变成现在这样的？” 根据上面的方法，我们就通常可以找到吐槽的对象了。但这还不够。有些时候这里显示出的作者可能是只重排了一下代码格式，并非真凶；又或者我们需要了解清楚代码是怎么一步步改成现在这样的，涉案人员都不能放过。所以接下来，我们要捋一遍这个文件的历史。 选择菜单 VCS → Git → Show History，PhpStorm 会在 Version Control 面板显示出当前文件的所有相关 commit 历史。（图三） 在这个历史记录中，双击任何一条 commit 即可查看它的 diff 视图。这样就可以深入分析某段代码的更改过程、定位到相应的 check-in 节点。（图四） 手边没有 IDE 怎么查？ 如果自己的电脑不在手边，也可以用浏览器登录 GitHub 网站，通过网页界面来一步步追查。我们进入项目 repo 的主页，打开某个文件的详情页面，在顶部可以发现 “Blame” 和 “History” 两个按钮（图五）： 其中，进入 Blame 页面可以查看文件内每行代码的作者信息（图六），其功能相当于图一。 而进入 History 页面可以查看这个文件的所有修改记录（图七），类似于图三。 在 History 页面点击任何一条 commit 即可查看该 commit 各文件的 diff 视图（图八），相当于图四。 吐槽 Commit 追查到问题代码真正的 check-in 节点后，就可进入相关 commit 的详情页面开始吐槽了。慢着，如何找到某个 commit 在 GitHub 上的详情页？ 如果你在 GitHub 网站进行追查，那么图八其实就是 commit 的详情页。此外，在图六 Blame 页面的左栏可以点击 commit 的标题或版本号直达该 commit 的详情页；图七中的每一行都链向每个 commit 的详情页。 如果你正在用 PhpStorm，且你的 PhpStorm 安装了 GitHub 插件，也比较好办。在类似图二的作者信息栏展开的状态下，右击任一 commit，在弹出菜单中选择 Open on GitHub，即可打开浏览器进入该 commit 的详情页。（图九） （需要注意的是，由于我们的工作 repo 都是 fork，所以这个操作打开的页面是你的 fork 中的这个 commit。你需要手动修改一下页面 URL 来进入项目 upstream 的对应的 commit 页面。） 如果你的 PhpStorm 没有安装 GitHub 插件，也可以试试另一种方法。在图九的右键菜单中选择 Copy revision number，即可得到该 commit 的版本号。然后使用以下模式手工构造一个 URL 打开即可： https://github.com/{org}/{project}/commit/{revision} 好了，在 commit 详情页的底部，我们可以发现一个评论框。（图十） 憋了这么半天，终于可以畅快地吐槽了！这个评论框具备完整的 GitHub 评论功能，我们可以使用 GitHub 风格的 Markdown 语法 书写富文本，可以引用其它 commit 或 PR、@ 别人、拖拽图片上传，很方便。 更优雅一点，吐槽 PR 在 GitHub 吐槽 commit 看起来很拉风，但这还不够，还可以更优雅一点。 上面说过，PR 是一座金矿，那里有很多讨论。找到某个 commit 所属的 PR，有助于我们更好地了解背景，避免喷错（安全第一啊）。 另一方面，当不良代码被合并到主干时，我们固然可以怪罪代码作者，但这更多是 review 者的责任。因为帮别人 review 代码的往往是有经验的资深工程师，帮助新人纠错和成长是他们的重要职责。因此，找到 PR 再吐槽，还可以揪出那些不认真 review 代码、“毁” 人不倦的导师们，直接打脸，岂不快哉！ 那么，如何通过 commit 找到它所属的 PR 呢？ 在上一节我们已经找到了 commit 的版本号，接下来，我们登录项目 upstream repo 的主页，在页面顶部有一个搜索框，填入 commit 的版本号，搜索。（图十一） （请留意此时搜索框的状态是 “This repository”，否则你可能进错了的页面。） 搜索结果往往为空。别着急，在页面左侧的搜索类型栏可以发现 “Issues” 有 1 条搜索结果，点击之。（图十二） 此时就可以找到这个 commit 是在哪个 PR 被合并到主干的啦（图十三）。尽情开动吧！ 做一个有情怀的吐槽狂 要知道，总会有一些害羞的同学不敢直面我的吐槽，他们总是假装没有收到我在 GitHub 的评论。为此，我写了这篇教程《如何正确接收 GitHub 的消息邮件》，并发给每个人，这样应该可以防止大家装睡了吧。 另外，在日常的吐槽工作中，我还会把一些典型的错误汇总起来，并招集大家听我当面吐槽一遍。虽然大家都很嫌弃我，但我丝毫不为所动，因为我是一个有情怀的吐槽狂，天生骄傲！ 转自： cssmagic/blog#51 ","link":"https://blog.coolcode.dev/post/20160107-18-如何在 GitHub 正确吐槽/"},{"title":"如何正确接收 GitHub 的消息邮件","content":"背景 我厂的开发流程通常都是基于 GitHub 的。在 GitHub 上 review 代码，也是我日常工作的重要组成部分。对我来说，在 code review 过程中最讨厌的莫过于，我在 pull request 或 commit 下面评论或 @ 人，往往石沉大海，没有回音。我事后追问当事人，他们的回复往往是 “不知道你 @ 我了呀～”。 这让我非常恼火。所以，我决定写篇文档给所有人看，避免他们漏看重要的 GitHub 消息。此后在 GitHub 不回复我的人，差不多也可以绝交了罢！ GitHub 的通知机制 通知的类型和方式 在两种情况下，我们会收到 GitHub 的通知。 我关注的（Watching）：当我关注了某个项目之后，相当于订阅了这个项目的所有更新，即这个项目的新 release、新 issue、新 PR 及所有讨论都会通知我。 我参与的（Participating）：当我参与到某个 issue、PR 或 commit 的讨论，或被别人 @ 后，我都会持续收到这个讨论的后续更新。 后面一种情况似乎对我更加重要一些。如果不需要密切跟进某个项目，我应该避免关注它。 另外，GitHub 会通过以下两种方式来通知我们： 站内信（Web）：当我登录 GitHub 网站时，如果有新消息，在导航栏会看到一个小蓝点。点进去就可以看到详细通知。 电子邮件（Email）：通知会直接发送到我的邮箱，而且我直接回复邮件的效果相当于登录到相关页面回复，非常方便。 可见，前者是被动方式，提醒能力太弱。而后者是主动推送，时效性好，但我需要注意的就是控制消息密度，避免被轰炸。因此，接下来，我们来了解一下 GitHub 的 “自动关注” 功能。 自动关注 不错过重要的消息，首先意味着不能被无关紧要的消息湮没。如果你经常收到大量的 GitHub 消息，那你可能就全都不看了。因此，我们需要关掉 “自动关注” 功能。 登录 GitHub 通知中心页面，即可关闭这个功能： 为什么要关它？这个功能很有意思，每当你获得了一个 repo 的 push 权限之后，GitHub 就会帮你自动关注这个 repo。这在开源社区是很有用的，因为当你获得了这个权限时，往往意味着你成为了这个 repo 的核心维护者，你确实需要第一时间掌握这个项目的一举一动。 但这对于公司内部项目就不那么合适了。比如我们的主站项目是一个私有 repo，几乎公司内的每位工程师都会 fork 它；同时出于协作的需要，每个 fork 都需要向所有工程师开放读写权限。因此，你将自动关注这近百个 repo，而这些 repo 的任何风吹草动都会通知你，即使你并未真正在其它同事的 fork 上工作。 总之，为了避免无关消息对你的轰炸，请关掉自动关注功能。你可能已经关注了一堆无关紧要的 fork 了，请记得在你的 关注列表页面 逐一取消。（如果你不是核心管理员，建议你把主站项目的 upstream 也取消关注。） 个人设置 了解完 GitHub 的特性之后，我们就可以针对性地做出配置和选择了。 设定 Email 正常情况下，每个人在工作时间都会开着自己的工作邮箱。那么首先，需要确保 GitHub 的消息是发到这个邮箱的。由于每个人的 GitHub 账号往往并非是用工作邮箱注册的，我们需要把邮箱搞对。 登录 GitHub 的邮箱设置页面，添加自己的工作邮箱。随后工作邮箱会收到一封验证邮件，完成验证之后，你的 GitHub 账号就绑定了两个邮箱。 （并不需要为把这个工作邮箱设置为 “primary”，只要验证通过就可以了。） 到这里我们就做好 Email 的准备工作。 通知中心 接下来，我们进入 GitHub 通知中心，为两种不同类型的通知选择通知方式。请确保至少第一个 “Email” 是被选中的： 接下来，选择接收邮件通知的邮箱。选择我们刚刚添加的工作邮箱，保存。 （这里的邮箱设置只会影响消息的接收，不会影响账号身份。） 好了，大功告成。从此以后，所有重要的 GitHub 消息都会发送到你的工作邮箱。最后，再告诉你几个小技巧，相信你用得上。 减少干扰 取消关注某个 Repo 前面已经提到过 你的关注列表，在那里，你可以随时清理不再重要的项目。同时，进入任何项目的页面，在右上角都可以选择对它的关注方式。 “Not watching” 意味着取消关注，你将不会收到与你无关的通知。而与你有关的（你发起的、主动参与的或被 @ 的）讨论有新回复，你还是会收到通知的。 请注意不要选择 “Ignoring”，那意味着你连重要的消息也收不到了。 取消关注某个讨论 当某个讨论已经没你什么事了，但仍然不断有后续消息涌进来，那就果断屏蔽它吧。从消息邮件中的链接点到网页，找到如下所示的 “取消订阅” 的按钮，即可取消关注这个讨论。 锁定某个讨论 当某个 issue 或 PR 已经没有继续讨论的必要的，你可以锁定它——当然前提是你得是这个 repo 的管理员。 屏蔽某个人 如果你遇到了无聊的人总是骚扰你，可以到它的用户页面，屏蔽并举报。 结语 相信看到这里，你已经对 GitHub 的通知机制十分了解了吧，并且应该可以灵活配置 GitHub 消息的接收方式了。 好吧，就这样吧。如果以后还是不回复我，绝交。 转自： cssmagic/blog#49 ","link":"https://blog.coolcode.dev/post/20160107-17-如何正确接收 GitHub 的消息邮件/"},{"title":"前端进阶之路：点击事件绑定","content":"引言 前端之所以被称为前端，是因为它是整个 Web 技术栈中距离用户最近、直接与用户进行交互的一环。而网页界面与用户的交互通常是通过各种事件来达成的；在各种事件之中，点击事件 往往又是最常见、最通用的一种界面事件。 本文将介绍我在 “点击事件绑定” 这一场景下的进阶之路。 背景 我是一个前端小兵，我在一家互联网公司做做一些简单的业务开发。 某一天，我接到了一个需求，做一个抽奖功能。公司里的前辈们已经完成了业务逻辑，而且已经提供了业务功能的接口，只需要我制作页面并完成事件绑定即可。 实践 开动 我写好了页面，页面中有一个 ID 为 lucky-draw 的按钮元素。接下来，我需要为它绑定点击事件。我是这样写的： var btn = document.getElementById('lucky-draw') btn.onclick = function () { BX.luckyDraw() } 这其中 BX.luckyDraw() 就是前辈们提供的业务接口，执行它就可以运行后续的抽奖功能。 我测试了一下，代码工作正常，于是很开心地准备上线。 第一关 然而前辈们告诉我，这些重要功能的按钮是需要加统计的。这也难不倒我，因为我很熟悉统计系统的 API。于是我修改了一下事件绑定的代码： btn.onclick = function () { BX.luckyDraw() BX.track('lucky-draw') } 这样做是有效的，但前辈们又告诉我，因为某些原因，统计代码和业务代码是分布在不同位置的，以上代码需要拆开。于是我尝试这样修改： btn.onclick = function () { BX.luckyDraw() } // other codes... btn.onclick = function () { BX.track('lucky-draw') } 结果发现点击按钮时的抽奖功能失效了。原来，使用 .onclick 这样的事件属性来绑定事件有一个非常大的缺点，重复赋值会覆盖旧值。也就是说，这种方式只能绑定最后一次赋值的事件处理函数。 我硬着头皮去请教前辈，才知道原来这种方式早已经不推荐使用了，应该使用 DOM 标准的事件绑定 API 来处理（在旧版 IE 下有一些兼容性问题，这里不展开）。因此我的代码改成了这样： btn.addEventListener('click', function () { BX.luckyDraw() }, false) // other codes... btn.addEventListener('click', function () { BX.track('lucky-draw') }, false) 所有功能终于又正常了，我很开心地准备上线。 第二关 事实证明我还是太天真了，PM 是不会一次性把所有需求都告诉你的。原来，这个抽奖功能还需要做 A/B 测试，也就是说，只有一半的用户会看到这个抽奖功能。 这意味着用户的页面上可能根本没有 btn 这个元素，那么 btn.addEventListener(...) 这一句直接就抛错了。因此，在为按钮绑定事件处理函数之前，我不得不先判断一下： if (btn) { btn.addEventListener('click', function () { BX.luckyDraw() }, false) } // other codes... if (btn) { btn.addEventListener('click', function () { BX.track('lucky-draw') }, false) } 虽然这样的代码在所有用户的页面上都可以正常工作，但这些预先判断看起来很蛋疼啊。我再次带着疑惑向前辈请教。前辈慈祥地看着我，说出了一句经典名言： 傻瓜，为什么不用万能的 jQuery 呢？ 原来，神奇的 jQuery 允许我们忽略很多细节，比如这种没有取到元素的情况会被它默默地消化掉。而且 jQuery 的事件绑定方法也不存在兼容性问题，API 也比较好看。不错不错，不管网上的大神们怎么喷 jQuery，但它简直是我的救星啊！ 于是，我的代码变成了以下这样： var $btn = $('#lucky-draw') $btn.on('click', function () { BX.luckyDraw() }) // other codes... $btn.on('click', function () { BX.track('lucky-draw') }) 我的代码看起来像那么回事了，我很开心地准备上线。 第三关 当然，我的故事不会这么快结束。要知道，对一个有追求的前端团队来说，不断提升用户体验是永恒的目标。比如，我们网站使用了一些方法来提升页面加载性能，部分页面内容并不是原本存在于页面中的，而是在用户需要时，由 JavaScript 动态生成的。 拿这个抽奖功能来说，抽奖按钮存在于一个名为 “惊喜” 的 tab 中，而这个 tab 在初始状态下是没有内容的，只有当用户切换到这个 tab 时，才会由 JS 填充其内容。示意代码是这样的： $('.tabs &gt; .surprise').on('click', function () { var htmlSurpriseTab = [ '&lt;div&gt;', '&lt;button id=&quot;lucky-draw&quot;&gt;Lucky Draw&lt;/button&gt;', '&lt;/div&gt;' ].join('') $('.tab-panels &gt; .surprise').html(htmlSurpriseTab) // BTN READY }) 这意味着，我写的事件绑定代码需要写在 // BTN READY 处。这种深层的耦合看起来很不理想，我需要想办法解决它。 我想起来，我在阅读 jQuery 文档时看到有一种叫作 “事件委托” 的方法，可以在元素还未添加到页面之前就为它绑定事件。于是，我尝试这样来写： $(document.body).on('click', '#lucky-draw', function () { BX.luckyDraw() }) 果然，我成功了！好事多磨啊，这个需求终于开心地上线了。 经过进一步的研究，我了解到 “事件委托” 的本质是利用了事件冒泡的特性。把事件处理函数绑定到容器元素上，当容器内的元素触发事件时，就会冒泡到容器上。此时可以判断事件的源头是谁，再执行对应 的事件处理函数。由于事件处理函数是绑定在容器元素上的，即使容器为空也没有关系；只要容器的内容添加进来，整个功能就是准备就绪的。 虽然事件委托的原理听起来稍有些复杂，但由于 jQuery 对事件委托提供了完善的支持，我的代码并没有因此变得很复杂。 多想一步 经过这一番磨炼，我收获了很多经验值；同时，我也学会了更进一步去发现问题和思考问题。比如，在我们的网页，通常会有多个按钮，那为它们绑定事件的脚本代码可能就是这样的： $body = $(document.body) $body.on('click', '#lucky-draw', function () { BX.luckyDraw() }) $body.on('click', '#some-btn', function () { // do something... }) $body.on('click', '#another-btn', function () { // do something else... }) 我隐隐觉得这样不对劲啊！虽然这些代码可以正常工作，但每多一个按钮就要为 body 元素多绑定一个事件处理函数；而且根据直觉，这样一段段长得差不多的代码是需要优化的。因此，如果我可以把这些类似的代码整合起来，那不论是在资源消耗方面，还是在代码组织方面，都是有益的。 于是，我尝试把所有这些事件委托的代码合并为一次绑定。首先，为了实现合并，我需要为这些按钮找到共同点。很自然地，我让它们具有相同的 class： &lt;button class=&quot;action&quot; id=&quot;lucky-draw&quot;&gt;Lucky Draw&lt;/button&gt; &lt;button class=&quot;action&quot; id=&quot;some-action&quot;&gt;Button&lt;/button&gt; &lt;a href=&quot;#&quot; class=&quot;action&quot; id=&quot;another-action&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;action&quot; id=&quot;another-action-2&quot;&gt;Link&lt;/a&gt; 然后，我试图通过一次事件委托来处理所有这些按钮： $body.on('click', '.action', function () { // WHEN CLICK ANY '.action', WE COME HERE. }) 很显然，所有具有 action 类名的元素被点击后都会触发上面这个事件处理函数。那么，接下来，我们在这里区分一下事件源头，并执行对应的任务： $body.on('click', '.action', function () { switch (this.id) { case 'lucky-draw': BX.luckyDraw() break case 'some-btn': // do something... break // ... } }) 这样一来，所有分散的事件委托代码就被合并为一处了。在这个统一的事件处理函数中，我们使用 ID 来区分各个按钮。 但 ID 有一些问题，由于同一页面上不能存在同名的元素，相信前端工程师们都对 ID 比较敏感，在日常开发中都尽量避免滥用。此外，如果多个按钮需要执行的任务相同，但它的 ID 又必须不同，则这些 ID 和它们对应的任务之间的对应关系就显得不够明确了。 于是，我改用 HTML5 的自定义属性来标记各个按钮： &lt;button class=&quot;action&quot; data-action=&quot;lucky-draw&quot;&gt;Lucky Draw&lt;/button&gt; &lt;button class=&quot;action&quot; data-action=&quot;some-action&quot;&gt;Button&lt;/button&gt; &lt;a href=&quot;#&quot; class=&quot;action&quot; data-action=&quot;another-action&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;action&quot; data-action=&quot;another-action-2&quot;&gt;Link&lt;/a&gt; 我在这里使用了 data-action 这个属性来标记各个按钮元素被点击时所要执行的动作。回过头看，由于各个按钮都使用了这个属性，它们已经具备了新的共同点，而 class 这个共同点就不必要了，于是我们的 HTML 代码可以简化一些： &lt;button data-action=&quot;lucky-draw&quot;&gt;Lucky Draw&lt;/button&gt; &lt;button data-action=&quot;some-action&quot;&gt;Button&lt;/button&gt; &lt;a href=&quot;#&quot; data-action=&quot;another-action&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot; data-action=&quot;another-action-2&quot;&gt;Link&lt;/a&gt; 同时 JS 代码也需要做相应调整： $body.on('click', '[data-action]', function () { var actionName = $(this).data('action') switch (actionName) { case 'lucky-draw': BX.luckyDraw() break case 'some-btn': // do something... break // ... } }) 我们的代码看起来已经挺不错了，但我已经停不下来了，还要继续改进。那个长长的 switch 语句看起来有点臃肿。通常优化 switch 的方法就是使用对象的键名和键值来组织这种对应关系。于是我继续改： var actionList = { 'lucky-draw': function () { BX.luckyDraw() }, 'some-btn': function () { // do something... } // ... } $body.on('click', '[data-action]', function () { var actionName = $(this).data('action') var action = actionList[actionName] if ($.isFunction(action)) action() }) 经过这样的调整，我发现代码的嵌套变浅了，而且按钮们的标记和它们要做的事情也被组织成了 actionList 这个对象，看起来更清爽了。 在这样的组织方式下，如果页面需要新增一个按钮，也很容易做扩展： // HTML $body.append('&lt;a href=&quot;#&quot; data-action=&quot;more-action&quot;&gt;Link&lt;/a&gt;') // JS $.extend(actionList, { 'more-action': function () { // ... } }) 到这里，这一整套实践终于像那么回事了！ 开源 我自己用这一套方法参与了很多项目的开发，在处理事件绑定时，它节省了我很多的精力。我忽然意识到，它可能还适合更多的人、更多的项目。那不妨把它开源吧！ 于是我发布了 Action 这个项目。这个小巧的类库帮助开发者轻松随意地绑定点击事件，它使用 “动作” 这个概念来标记按钮和它被点击后要做的事情；它提供的 API 可以方便地定义一些动作： action.add({ 'my-action': function () { // ... } }) 也可以手动触发已经定义的动作： action.trigger('my-action') 应用 Action 这个类库已经被移动 Web UI 框架 CMUI 采用，作为全局的基础服务。CMUI 内部的各个 UI 组件都是基于 Action 的事件绑定机制来实现的。我们这里以对话框组件为例，来看看 Action 在 CMUI 中的应用（示意代码）： CMUI.dialog = { template: [ '&lt;div class=&quot;dialog&quot;&gt;', '&lt;a href=&quot;#&quot; data-action=&quot;close-dialog&quot;&gt;×&lt;/a&gt;', '&lt;h2&gt;&lt;%= data.title %&gt;&lt;/h2&gt;', '&lt;div class=&quot;content&quot;&gt;&lt;%- data.html %&gt;&lt;/div&gt;', '&lt;/div&gt;' ].join(''), init: function () { action.add({ 'close-dialog': function () { $(this).closest('.dialog').hide() } }) }, open: function (config) { var html = render(this.template, config) $(html).appendTo('body').show() } } CMUI.dialog.init() 只要当 CMUI.dialog.init() 方法执行后，对话框组件就准备就绪了。我们在业务中直接调用 CMUI.dialog.open() 方法、传入构造对话框所需要的一些配置信息，这个对话框即可创建并打开。 大家可以发现，在构造对话框的过程中，我们没有做任何事件绑定的工作，对话框的关闭按钮就自然具备了点击关闭功能！原因就在于关闭按钮（×）自身已经通过 data-action 属性声明了它被点击时所要执行的动作（'close-dialog'），而这个动作早已在组件初始化时（CMUI.dialog.init()）定义好了。 结语 希望本文对你有所启发，也希望 Action 能在实际开发中帮到你。 关于更多细节，欢迎继续阅读： Action 的更多介绍 CMUI 项目 jQuery 的事件绑定 API 转自： cssmagic/blog#48 ","link":"https://blog.coolcode.dev/post/20160107-16-前端进阶之路：点击事件绑定/"},{"title":"如何写就完美 Pull Request","content":" 译注：Github Blog 发表了一篇文章 How to write the perfect pull request，对书写 Pull Request 文案及相关话题给了些相当不错的建议，很适合开源协作，对使用 Github 的公司项目也有一些借鉴价值。祝愿大家都能写一手好文档，沟通愉快！ 随着公司规模增长，人和项目都在变化。在 Github，我们的经验是经常提醒自己沟通的目标非常有助于保持沟通的高效，为此我们最近提出了一份关于提交 Pull Request 的指南，帮助大家在使用 Pull Request 时能更好地协作。 撰写 Pull Request 要涵盖此次 Pull Request 的目标，例如： 尝试用 XXX 方法实现…… 优化…… 修复在 XX 状态下对 XX 的异常处理 可以提供一份关于这些工作起因的说明（包含上相关链接）。不要假定对方已经熟悉这些事情的前因后果。 记住公司里任何人都有可能来阅读这个 Pull Request，所以内容和语气都需要面向那些未参与工作内容的人，现在和未来的。 如果有的话，请详述你需要的反馈，如：快速过目一下代码/讨论某项技术实现/对设计的意见等等。 明确你何时需要反馈。如果这个 PR 还在没有完成，就需要这么注明一下。给标题加上[WIP]（施工中）的前缀也是个简便快捷的方法。 @艾特 需要特别指明加入讨论的人，并说明原因（“/cc @hax 麻烦来看下这个逻辑对么？”）。 同样的方法也可以艾特团队（“/cc @baixing/sa 这么做没安全问题吧？”）。 提供反馈 首先要了解下此 PR 的前情提要。 如果你有强烈的反对意见，多花几分钟审视下自己的意见再做反馈。Think Twice。 询问，不要指点。（“为什么你要……”而非“不要……”） 解释你提出修改意见的原因。（和代码规范不符？个人喜好？） 提供简化或改进代码的方法。 在提到别人的工作成果时避免使用贬义词（愚蠢什么的）。 谦逊。（“我不很确定，不过可以试试……”） 不要夸张。（“任何时候绝对……”） 评论旨在提高专业技能、产品质量，达成团队共识。 在线交流时要当心负面歧义（如果文字内容中性，我们倾向认为语气偏负面），尽量使用积极的语气而非中性的。 善用表情符号美化语气。（感受一下 “看起来不错。” 和 “ 看起来不错 ”） 对反馈的回复 考虑以感激作为开场白，尤其是当反馈混杂了各种意见的时候。 如有不明白的地方，请求进一步澄清。（“我不大明白，你能再解释一下么？”） 提供澄清。解释对方询问的实现方案是如何决策的。 尽量回复所有评论。 链接到相关的后续提交。（“好建议！a1da2324ca 已搞定 😄”） 如果疑惑和争论持续扩大，首先审视自己在前面的讨论中是否表达良好，尝试面对面做充分沟通，之后把线下沟通的内容汇总回复（便于其他人跟踪进展或未来了解详情）。 这份指南部分受到了 ThoughtBot 的 Code Review 指南的启发。 这份指南很适合我们的工作方式，以及我们想要建立的协作文化，希望对你也有帮助。 沟通愉快！ 可以结合这篇一起看：http://www.infoq.com/cn/news/2015/02/pull-reques-ten-suggestion 再加两条： 如果有代码格式化整理，记得把格式化的操作作为独立的一次提交。不要和代码修改混在一起，以便 Review 的人能方便查看干净的代码修改 diff。 注明所有修改内容。如果确有必要将几件事情（例如特别小、相互有依赖等）一起提交 PR，则需要列明具体每一件事情。 原文: https://github.com/baixing/FE-Blog/issues/1 ","link":"https://blog.coolcode.dev/post/20160107-15-如何写就完美 Pull Request/"},{"title":"2015 年最热门的国人开发开源软件 TOP 50","content":"开源中国在 2015 年得到了快速的发展，单开源软件收藏量就接近 40000 款，其中不乏优质的国产开源项目。本文从软件的收藏、下载、访问等多角度挑选出了 2015 年最热门的国产开源软件前五十名，让各位对过去一年国产开源项目发展有所了解。 1.Dos.ORM Dos.ORM（原Hxj.Data）于2009年发布，并发布实体生成工具。在开发过程参考了多个ORM框架，特别是NBear，MySoft、EF、Dapper等。吸取了他们的一些精华，加入自己的新思想。该组件已在上百个成熟企业项目中应用。 开发语言：C# 授权协议：MIT 源码下载：http://git.oschina.net/ITdos/Dos.ORM 软件作者：ITdos 2.WeUI WeUI 是由微信官方设计团队专为微信移动 Web 应用设计的 UI 库。WeUI 是一套同微信原生视觉体验一致的基础样式库，为微信 Web 开发量身设计，可以令用户的使用感知更加统一。包含button、cell、dialog、toast、article、icon等各式元素。 开发语言：JavaScript HTML/CSS 授权协议：MIT 源码下载：https://github.com/weui/weui 软件作者：腾讯 3.EOVA 基于JFinal开发，首创JFinal 快速开发平台，JFinal最佳实践！大家好我是Java的表弟Eova，中文名:伊哇。我可以快速完成开，发任务，信手拈来，我会10大控件,4大组件,N种业务模型，常见的增删改查、条件查询、数据校验、前后置业务处理、批量操作、权限管理...通通能帮你快速搞定。我的全称是——Easy Object View Admin(简单对象视图管理系统) 开发语言：Java JavaScript HTML/CSS 授权协议：GPL 源码下载：http://git.oschina.net/eova/eova 软件作者：Jieven 4.EasyPR EasyPR是一个中文的开源车牌识别系统，其目标是成为一个简单、灵活、准确的车牌识别引擎。 开发语言：C/C++ 授权协议：Apache 源码下载：http://git.oschina.net/easypr/EasyPR 软件作者：刘若则 5.Editor.md Editor.md** **是一个可嵌入的开源 Markdown 在线编辑器组件，你可以很方便用在浏览器、NW.js（Node-webkit）等地方，基于CodeMirror、jQuery 和 Marked 构建。 开发语言：JavaScript HTML/CSS 授权协议：MIT 源码下载：http://git.oschina.net/pandao/editor.md 软件作者：叛道 6.Open-Falcon Open-Falcon 人性化的互联网企业级监控系统，Open-Falcon 整体可以分为两部分，即绘图组件、告警组件。其中：安装绘图组件负责数据的采集、收集、存储、归档、采样、查询、展示 （Dashboard/Screen）等功能，可以单独工作，作为time-series data的一种存储展示方案。安装告警组件负责告警策略配置（portal）、告警判定（judge）、告警处理（alarm/sender）、用户组管 理（uic）等，可以单独工作。 开发语言：Go 授权协议：Apache 源码下载：https://github.com/xiaomi/open-falcon 软件作者：UlricQin 7.Parallec Parallec 是一个基于Akka的快速并行异步HTTP(S)/SSH/TCP/Ping 客户端的Java库。它是eBay云计算部门开发并在REST Superman基础上开源的。Parallec的寓意是&quot;并行客户端&quot;： Parallel Client, 发音如 &quot;Para-like&quot;。 开发语言：Java 授权协议：Apache 源码下载：https://github.com/eBay/parallec 软件作者：jeffpeiyt 8.OpenCenter OpenCenter是一款基于ThinkPHP的用户中心产品。其介于框架和应用之间，提供通用的用户中心和后台模块给开发者用来实现自己的业务系统。基于Apache2.0的开源协议，对商业友好，永久开源免费。 开发语言：PHP 授权协议：Apache 源码下载：http://git.oschina.net/yhtt2020/OpenCenter 软件作者：陈一枭 9.Disconf Disconf 可以为各种业务平台提供统一的配置管理服务。支持配置（配置项+配置文件）的分布式化管理；配置发布统一化；极简的使用方式（注解式编程 或 XML代码无代码侵入模式）；低侵入性或无侵入性、强兼容性；需要Spring编程环境。 开发语言：Java 授权协议：GPL 源码下载：https://github.com/knightliao/disconf 软件作者：knightliao 10.WeX5 WeX5对跨平台多前端应用开发的支持极好，一次开发，多平台运行。WeX5 采用混合应用（hybrid app）开发模式, UI体系完全基于w3c的html5+css3+js；引入jquery和bootstrap并对移动做了极致优化，效率极高。WeX5本机API Framework采用phonegap(cordova)框架。 开发语言：Java PHP JavaScript HTML/CSS 授权协议：Apache 源码下载：http://git.oschina.net/X5OK/WeX5 软件作者：WeX5开源前端 11.Inception MySQL语句的审核，在业界都已经基本被认同了，实际上也是对MySQL语句写法的统一化，标准化，而之前的人工审核，针对标准这个问题其实是很 吃力的，标准越多，DBA越累，开发也越累。 那么在这个都追求自动化运维的时代，审核也必须要跟上步伐，因此Inception诞生了。 开发语言：C/C++ 授权协议：GPLv2 源码下载：https://github.com/mysql-inception/inception 软件作者：王竹峰 12.EasyDarwin EasyDarwin是由国内开源流媒体团队开发和维护的一款开源流媒体平台框架，从2012年12月创建并发展至 今，从原有的单服务的流媒体服务器形式，扩展成现在的云平台架构的开源项目，更好地帮助广大流媒体开发者和创业型企业快速构建流媒体服务平台，更快、更简 单地实现最新的移动互联网(安卓、IOS、微信)流媒体直播与点播的需求，尤其是安防行业与互联网行业的衔接。 开发语言：C/C++ 授权协议：APSL 源码下载：http://www.easydarwin.org/ 软件作者：EasyDarwin 13.Lepus Lepus（天兔） 是数据库企业监控系统，针对互联网企业开发的一款专业、强大的企业数据库监控管理系统，企业通过Lepus可以对数据库的实时健康和各种性能指标进行全方位的监控。目前已经支持MySQL、Oracle、MongoDB、Redis数据库的全面监控。 开发语言：Python 授权协议：GPLv2 源码下载：http://git.oschina.net/ruzuojun/Lepus 软件作者：andrew_ru 14.Pholcus Pholcus（幽 灵蛛）是一款纯Go语言编写的高并发、分布式、重量级爬虫软件，支持单机、服务端、客 户端三种运行模式，拥有Web、GUI、命令行三种操作界面；规则简单灵活、批量任务并发、输出方式丰富（mysql/mongodb/csv /excel等）、有大量Demo共享；同时她还支持横纵向两种抓取模式，支持模拟登录和任务暂停、取消等一系列高级功能。 开发语言：Go 授权协议：Apache 源码下载：https://github.com/henrylee2cn/pholcus 软件作者：henrylee2cn 15.AOS AOS 应用基础平台基于JavaEE技术体系，以“标准功能可复用、通用模块可配置、行业需求快速开发、异构系统无缝集成”为目标，为软件开发团队提供高效可 控、随需应变、快速实现业务需求的全栈式技术解决方案。帮助企业落实IT策略、屏蔽技术壁垒，快速实现业务愿景。使其获得更低成本、更高质量、更快交付业 务和运维支持的核心技术竞争力。 开发语言：Java 授权协议：其他 源码下载：http://git.oschina.net/osworks/AOS 软件作者：AHei 16.TiDB TiDB 是国内 PingCAP 团队开发的一个分布式 SQL 数据库。其灵感来自于 Google 的F1, TiDB 支持包括传统 RDBMS 和 NoSQL 的特性。 开发语言：Go 授权协议：Apache 源码下载：http://git.oschina.net/ngaut/tidb 软件作者：goroutine 17.JFlow CCFlow是.net版本的简称，由济南团队负责研发，JFlow是在java版本的简称，在ccflow的基础上升级改造而来，由深圳海天慧瑞团队研 发。两款产品向社会100%开源，十多年来，我们一直践行自己的诺言，真心服务中国IT产业，努力提高产品质量，成为了国内知名的老牌工作流引擎。 开发语言：Java 授权协议：Apache 源码下载：http://git.oschina.net/chichengsoft/JFlow 软件作者：ccflow 18.DINP DINP是一个基于Docker开发的PaaS平台。PaaS平台是个规范性很强的平台，app要用PaaS托管，必须要满足1、2、3...n条规范才可以。web应用通常无状态，逻辑简单，部署方式统一 故而可以使用PaaS托管。但对于一些分布式大型软件、复杂的rpc服务，部署架构复杂，并不适合用PaaS托管。有所为有所不为，DINP只接管web 应用。 开发语言：Go 授权协议：Apache 源码下载：http://git.oschina.net/cnperl 软件作者：UlricQin 19.Foreign LINUX Foreign LINUX 项目旨在让用户能在Windows上不做任何修改的跑Linux二进制文件。自由软件社区有一个类似的项目叫Cygwin， 但需要重新编译才能将Linux或BSD上的软件运行在Windows上。Foreign LINUX绕过了这一对普通用户来说过于困难的过程，它是一个动态二进制翻译器和Linux系统调用接口模拟器，目前它处于早期开发阶段，能运行的 Linux工具包括bash、vim、nano、python、gcc等。 开发语言：C/C++ 授权协议：GPLv3 源码下载：https://github.com/wishstudio/flinux 软件作者：wishstudio 20.ABTestingGateway ABTestingGateway 是一个可以动态设置分流策略的灰度发布系统，工作在7层，基于nginx和ngx-lua 开发，使用 redis 作为分流策略数据库，可以实现动态调度功能。 开发语言：Lua 授权协议：MIT 源码下载：http://www.oschina.net/p/abtestinggateway 软件作者：SinaMSRE 21.Dexposed Dexposed 是阿里巴巴无线事业部第一个重量级 Andorid 开源软件，基于 ROOT 社区著名开源项目 Xposed 改造剥离了 ROOT 部分，演化为服务于所在应用自身的 AOP 框架。它支撑了阿里大部分 App 的在线分钟级客户端 bugfix 和线上调试能力。 开发语言：Java C/C++ 授权协议：Apache 源码下载：https://github.com/alibaba/dexposed 软件作者：阿里巴巴 22.PSI PSI是开源进销存。PSI是希腊字母Ψ的读音。产品寓意：PSI本身不完美，但追求的是不断改进的品质，距离终极产品就一步之遥(因为在希腊字母表中，Ψ之后是Ω，Ω有终极的意思)。 开发语言：PHP 授权协议：GPL 源码下载：http://git.oschina.net/crm8000/PSI 软件作者：李静波 23.Oceanus Oceanus致力于打造一个功能简单、可依赖、易于上手、易于扩展、易于集成的解决方案，甚至是平台化系统。拥抱开源，提供各类插件机制集成其他开源项目，新手可以在几分钟内上手编程，分库分表逻辑不再与业务紧密耦合，扩容有标准模式，减少意外错误的发生。 开发语言：Java 授权协议：Apache 源码下载：https://github.com/58code/Oceanus 软件作者：58 同城 24.Nuclear Nuclear 是腾讯 AlloyTeam 团队开发的一款形似 React 的超轻量级框架(大小16k，gzip后6k)。Nuclear不需要jsx，你只需要使用纯粹的javascript就可以使用面向对象的方式去编写各式各样的组件。Nuclear的目标是让布局、样式、数据、事件、行为完全独立，让程序更加易维护、可扩展。 开发语言：JavaScript HTML/CSS 授权协议：MIT 源码下载：https://github.com/AlloyTeam/Nuclear 软件作者：kmdjs 25.Yac Yac 是为PHP实现的一个基于共享内存, 无锁的内容Cache。Yac的两个应用场景:1.让PHP进程之间共享一些简单的数据；2.高效地缓存一些页面结果。 开发语言：C/C++ PHP 授权协议：PHP 源码下载：https://github.com/laruence/yac 软件作者：Laruence 26.PhalApi PhalApi是一个PHP轻量级后台接口开发框架。我们致力于将PhalApi维护成像恒星一样：不断更新，保持生气；为接口负责，为开源负责！让后台接口开发更简单！ 开发语言：PHP 授权协议：GPL 源码下载：http://git.oschina.net/dogstar/PhalApi 软件作者：暗夜在火星 27.tsf tsf （Tencent Server Framework） 是腾讯公司推出的 PHP 协程方案，基于Swoole+PHP Generator 实现的 Coroutine。Tencent Server Framework 是快速服务器部署框架，PHP 现在可以像 Golang 一样用协程实现高并发服务器，同时支持同步阻塞，异步非阻塞回调，协程这 3 种 IO 模型。 开发语言：PHP 授权协议：Apache 源码下载：http://www.oschina.net/p/tsf 软件作者：腾讯 28.F2etest F2etest 是一个面向前端、测试、产品等岗位的多浏览器兼容性测试整体解决方案。在这个解决方案中，我们使用了以下技术：Guacamole: 开源的HTML5远程解决方案，Windows Server: Server版Windows，最大化复用机器资源，hostsShare: 跨浏览器，跨服务器的hosts共享。 开发语言：Java JavaScript 授权协议：MIT 源码下载：https://github.com/alibaba/f2etest 软件作者：阿里巴巴 29.Bolt Bolt是一个实时裁剪压缩图片服务器，其比nginx的image_filter快2倍以上，主要是因为Bolt对一张图片只做一次处理，就算在处理图片的过程中，其他的客户端也在请求此图片，Bolt也能保证只有一个线程在处理此图片。 开发语言：C/C++ 授权协议：GPL 源码下载：http://git.oschina.net/liexusong/bolt 软件作者：liexusong 30.Resty Resty 拥有 jfinal/activejdbc 一样的 activerecord 的简洁设计，使用更简单的 restful 框架部分设计也来 jfinal+activejdbc+restx。 开发语言：Java 授权协议：Apache 源码下载：https://github.com/Dreampie/Resty 软件作者：Dreampie 31.Mycat MyCAT 是一个彻底开源的，面向企业应用开发的“大数据库集群” 支持事务、ACID、可以替代Mysql的加强版数据库。一个可以视为“Mysql”集群的企业级数据库，用来替代昂贵的Oracle集群。 开发语言：Java 授权协议：Apache 源码下载：http://git.oschina.net/linzhiqiang/Mycat-Server 软件作者：风-- 32.Leaf/go Leaf 是一个使用 Go 语言开发的开源游戏服务器框架，注重运行效率并追求极致的开发效率。Leaf 适用于几乎所有的游戏类型。 开发语言：Go 授权协议：Apache 源码下载：https://github.com/name5566/leaf 软件作者：Name5566 33.MPSDK4J MPSDK4J，非常直观的阐述了此项目的意义所在。没错，它就是JAVA语言环境下的微信公众平台开发SDK。其中MP代表的是微信公众平台的域名前缀，SDK表示开发工具包，4同音英文“for”，J代表了JAVA。 开发语言：Java 授权协议：Apache 源码下载：http://git.oschina.net/lisenhui/mpsdk4j 软件作者：凡梦星尘 34.Mapv Mapv 是一款基于百度地图的大数据可视化开源库，可以用来展示大量的点、线、面的数据，每种数据也有不同的展示类型，如直接打点、热力图、网格、聚合等方式展示数据。 开发语言：JavaScript 授权协议：MIT 源码下载：https://github.com/huiyan-fe/mapv 软件作者：Kai_Ni 35.Uncode Uncode是移动后端服务平台，由Uncode团队开发，现全面开源，是一套开源的MBaaS软件，旨在让移动后端开发变得更简单。任何企业或个人，通 过Uncode都可以给移动应用快速定制个性化的后端业务逻辑，可以大大降低后端开发时间和成本。Unocde提供了这种灵活性，可以让您的代码实现非常 简单，并直接运行。 开发语言：Java 授权协议：GPL 源码下载：https://git.oschina.net/uncode/uncode-baas 软件作者：冶卫军 36.DDMS DDMS(Data Drive Management System) 是一个刚刚起步，基于 Express 的表单管理系统。后端 view engine 和部分 UI 用的是 ReactJS。用于让运营团队创建复杂的表单结构模板，让前端能有更多属性作条件判断从而可进行丰富逻辑的交互。 开发语言：JavaScript 授权协议：MIT 源码下载：https://github.com/unbug/ddms 软件作者：unbug 37.NGOOS NGOOS 极益平台-打造极致公益 极益基于强大的 TYPO3 平台，传承优秀的基因和强大的基础。为落后的公益带来强大的雄性激素！TYPO3自1998年开发以来，历经17年的社群开发， 具备上万的功能和模块，在全球支持上百万站点。 开发语言：PHP 授权协议：GPL 源码下载：http://git.oschina.net/ngo/os 软件作者：极益科技 38.Speedy Speedy 是京东公司开发的 Docker 镜像存储系统。 开发语言：C/C++ 授权协议：MIT 源码下载：https://github.com/jcloudpub/speedy 软件作者：swingbach 39.AndFix AndFix 是阿里巴巴开源的 Android 应用热修复工具，帮助 Anroid 开发者修复应用的线上问题。Andfix 是 &quot;Android hot-fix&quot; 的缩写。 开发语言：Java C/C++ 授权协议：Apache 源码下载：https://github.com/alibaba/AndFix 软件作者：阿里巴巴 40.EasyFlash EasyFlash是一款开源的轻量级嵌入式Flash存储器库，主要为MCU(Micro Control Unit)提供便捷、通用的上层应用接口，使得开发者更加高效实现基于的Flash存储器常见应用开发。 开发语言：C/C++ 授权协议：MIT 源码下载：http://git.oschina.net/Armink/EasyFlash 软件作者：armink 41.emqttd emqttd 是采用Erlang语言开发，全面支持MQTT V3.1.1协议，支持集群和大规模连接的开源MQTT消息服务器。emqttd致力于发布一个基于Erlang/OTP语言平台，企业级稳定可靠，完全 开源免费，可集群支持大规模物联网、移动互联网连接的MQTT消 息服务器。 开发语言：Erlang 授权协议：MIT 源码下载：https://github.com/emqtt/emqttd 软件作者：emqtt 42.AEAIHR AEAIHR人力资源管理系统是数通畅联软件基于AEAI DP开发的开源Java Web系统，用来协助管理公司人力、薪酬等事务， AEAI HR人力资源系统包括一些核心的人力资源管理业务功能，如：薪酬管理、考勤管理、绩效管理等模块，同时支持移动签到、签退（移动支持是V1.5版本新特性）能够满足企业人力资源信息化的基本要求。 开发语言：Java 授权协议：BSD 源码下载：http://www.oschina.net/p/aeaihr 软件作者：数通畅联 43.OurTimes OurTimes 是一个基于位置的通讯录(built on Node + MongoDB + AngularJS)。 开发语言：JavaScript 授权协议：MIT 源码下载：https://github.com/vczero/OurTimes 软件作者：vczero 44.AlloyGameEngine AlloyGameEngine 让游戏制作变得超级容易，超快的 2d 渲染引擎，支持 webgl 和 canvas 渲染。 开发语言：JavaScript 授权协议：Apache 源码下载：http://my.oschina.net/AlloyTeam 软件作者：AlloyTeam 45.QCEditor QCEditor是一个简单的cocos2d-x编辑器。 Qt和Cocos-x 都能跨平台，理论上是能够跨平台的。名字是 Qt 和 Cocos2d-x 的首字母缩写。写这个编辑器的目的是为了实现一个能摆放ui控件位置的功能，我们在游戏开发过程中通常也只会用到这个功能。 开发语言：C/C++ 授权协议：MIT 源码下载：http://git.oschina.net/qcdong/QCEditor 软件作者：qcdong 46.oct oct 是用于开放容器的测试用例和框架，用 Go 语言开发。ocp-testing 项目的目标是，通过提供全局测试框架给所有的容器项目，来提高开放容器项目。测试包括，ocp 规范，容器功能和容器性能。 开发语言：Go 授权协议：Apache 源码下载：https://github.com/huawei-openlab/oct 软件作者：华为 47.Parallec Parallec 是一个基于Akka的快速并行异步HTTP(S)/SSH/TCP/Ping 客户端的Java库。它是eBay云计算部门开发并在REST Superman基础上开源的。Parallec的寓意是&quot;并行客户端&quot;： Parallel Client, 发音如 &quot;Para-like&quot;. 更多说明请见这里。 开发语言：Java 授权协议：Apache 源码下载：https://github.com/eBay/parallec 软件作者：jeffpeiyt 48.OpenDroid opendroid 是 Android 上的一个开源 ORM 框架，可以轻松实现将数据库中的数据映射到java bean中、将java bean持久化到sqlite中。opendroid也提供了强大的数据库升级方案，只需修改一个参数即可实现数据库升级，opendroid会自动将旧 数据更新到新表中，免除数据库升级数据丢失的烦恼。 开发语言：Java 授权协议：Apache 源码下载：http://git.oschina.net/qibin/OpenDroid 软件作者：亓斌哥哥 49.goim goim 是一个支持集群的im及实时推送服务（支持websocket，http和tcp协议）。 开发语言：Go 授权协议：GPL 源码下载：https://github.com/Terry-Mao/goim 软件作者：LoveSai 50.phptrace phptrace 是一个追踪（trace）PHP执行流程的工具，你如果用过strace的话，则可能很容易想到phptrace到底实现了什么样的功能。 其实，phptrace是类strace的一个实现，不同的是，strace用来追踪系统调用，而phptrace用来追踪PHP函数调用。 开发语言：PHP 授权协议：GPL 源码下载：https://github.com/Qihoo360/phptrace 软件作者：simpcl ","link":"https://blog.coolcode.dev/post/20160104-14-2015 年最热门的国人开发开源软件 TOP 50/"},{"title":"配置CentOS-7-x86_64-Minimal镜像文件安装的系统","content":"更新系统，并且安装wget yum update yum install wget -y 使用阿里的yum源替换系统默认的yum源 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum makecache 安装系统必备组件 yum install telnet perl perl-devel net-tools kernel-devel -y yum groupinstall &quot;Development tools&quot; -y CentOS 7的防火墙关闭和iptables安装 CentOS 7.0默认使用的是firewall作为防火墙，但可能一下子很难适应，让我们先改回原先的iptables防火墙吧！ 关闭CentOS 7的firewall： systemctl stop firewalld.servic #停止firewall systemctl disable firewalld.service #禁止firewall开机启动 启动iptables防火墙 systemctl restart iptables.service #最后重启防火墙使配置生效 systemctl enable iptables.service #设置防火墙开机启动 ","link":"https://blog.coolcode.dev/post/20160103-13-配置CentOS-7-x86_64-Minimal镜像文件安装的系统/"},{"title":"Mac上WebStorm无法输入中文标点","content":"Mac上JDK_1.8.51或以上版本存在无法输入中文标点的bug，需要删除这个JDK，重新安装JDK_1.8.45版本。 删除高版本 sudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.8.0_* sudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPane sudo rm -rf Library/Internet\\ Plug-Ins/JavaAppletPlugin.plugin 重新安装JDK_1.8.45版本 打开WebStorm，快捷键command+shift+a，查找JDK，选择安装的JDK_1.8.45，重启WebStorm解决。 ","link":"https://blog.coolcode.dev/post/20160102-9-Mac上WebStorm无法输入中文标点/"},{"title":"java Servlet+mysql 调用带有输入参数和返回值的存储过程","content":"原文:http://www.cnblogs.com/xiaoliao/p/5094151.html 这个数据访问的功能，我在.NET+Mysql .NET+Sqlserver PHP+Mysql上都实现过，并且都发布在了我博客园里面，因为我觉得这个功能实在是太重要，会让你少写很多SQL语句不说，还能提高程序的执行效率。 今天在JAVA+Mysql上也实现了这个功能下面我贴出代码，这次我会讲详细点，让看的朋友能更加清楚它的好处在哪里。 一、封装的代码存储过过程调用方法 关于返回类CallableStatement的解释: CallableStatement 对象为所有的DBMS提供了一种以标准形式调用已储存过程的方法。已储存过程储存在数据库中。对已储存过程的调用是CallableStatement对象所含的内容。这种调用是用一种换码语法来写的，有两种形式：一种形式带结果参，另一种形式不带结果参数。结果参数是一种输出 (OUT) 参数，是已储存过程的返回值。两种形式都可带有数量可变的输入（IN 参数）、 输出（OUT 参数）或输入和输出（INOUT 参数）的参数。问号将用作参数的占位符 。 // 调用带有输入参数且有返回值的存储过程 public static CallableStatement callProcInputAndOutPut(String sql, String[] inparameters) { try { conn = getConnection(); cs = conn.prepareCall(sql); if(inparameters!=null) for(int i=0;i&lt;inparameters.length;i++) { //if中循环的参数是我们，在存储过程需要使用到的参数 if (i&lt;inparameters.length-1) { cs.setObject(i+1, inparameters[i]); } //else中的参数是我们存储过程执行完毕后返回给我们的值，它会被保存在CallableStatement这个类里面， //然后我们可以根据传入参数时所在的位置,这个位置就是传入的数组参下标+1去取存储过程返回给我们的值 else { cs.registerOutParameter(2, java.sql.Types.VARCHAR); } } cs.execute(); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e.getMessage()); }finally{ } return cs; } 二、调用方法的代码 /*调用带output参数的存储过程*/ //下面就是我们组合的参数,其中第一个是存储过程所需参数，第二个&quot;&quot;没有赋值的参数就对应存储过程中的输出参数，就是我们需要的返回值 String[] sqlParameter=new String[]{&quot;hellow&quot;,&quot;&quot;}; //调用存储过程的的字符串 String executString=&quot;call outputProcudure(?,?)&quot;; //调用存储过程的的字符串 outPutProcudure就是我们的存储过程名称，然后两个?表示两个参数，1是我们参数的参数，第二是我们存储过程处理完后返回的值 CallableStatement proReturnData=MySqlHepler.callProcInputAndOutPut(executString, sqlParameter); try { //取值 由于带OUT参数的返回值在我们存储过程中参数的位置是第二位所以我们 使用GETINT(2),接着我会贴存储过程 int returnValue= proReturnData.getInt(2); if (returnValue==1) { String groupAlertString=&quot;返回值是:&quot;+returnValue+&quot;---&gt;插入成功.&quot;; out.println(groupAlertString); } else { String groupAlertString=&quot;返回值是:&quot;+returnValue+&quot;---&gt;插入失败，该用户名已经存在.&quot;; out.println(groupAlertString); } } catch (SQLException e) { e.printStackTrace(); } 三:存储过程 这里我详细说下:这个调用的存储过程执行的步骤很简单，就是传入一个名称，然后判断数据库中是否有相同名称的人员，如果有就返回2（不插入)，如果没就返回1(表示我们以hellow为名称给数据库中增加了一条数据。 这个步骤如果是直接写SQL语句是必须写两条的，但是这里用到了存储过程，就只需要如此简单一步就处理了... 也许你觉得我这个例子举得不正确,也许你还会想，我们可以将这个名称字段设置个主键啊，不就一个SQL语句就行了吗，呵呵不过我这里说了。 我只是举了这么一简单的例子，SQL操作复杂逻辑的地方太多了。。...也许连带操作的有10步如果你写SQL语句就需要10次访问数据，那么这时候你再来看这个例子。 下面贴存储过程的图: 四:执行效果 第一次调用存储过程截图 第二次调用存储过程截图 ","link":"https://blog.coolcode.dev/post/20160102-8-java Servlet+mysql 调用带有输入参数和返回值的存储过程/"},{"title":"服务端技术选型","content":"服务框架 MVC Framework：Rose 框架简单易用，并且我米内部服务和工具都优先支持 Rose 项目，默认使用 Rose 框架是很好的选择。文艺一点想做个异步化 web 服务，可以选择 Spring MVC 3.2 以上版本，并搭配高版本 Resin/Jetty 服务器，该方案已有线上服务使用，只是搭项目时会稍复杂些。 RPC：我们线上使用的是 Apache Thrift，是 0.5.0 版本。我们计划下一步升级并完善他。具体可以访问我们的 Thrift RoadMap 页面。 Javascript Library：随大流用 JQuery，也可以申请前端支持。 CSS Framework：用 Bootstrap。 Database ORM Framwork：自然是 paoding-rose-jade，成熟好用，无论是简单的数据表操作，或者是“高大上”的分表分库都不在话下。更集成了 perfcouter 功能，可以实时查看和监控 MySQL 语句执行效率。 数据库连接池：jade 使用 Apache DBCP。Tomcat JDBC 声称更快更强，还没测试过，暂时还是继续 Apache DBCP 吧。 No SQL：Hadoop, Hive, HBase。 Cache：本地 cache 使用 Ehcache，Guava 的 cache 也可以使用。中央式缓存，用 Memcached。 传统数据库：MySQL。线上业务先和 DBA 确认服务器磁盘是否是 SSD。 Utilizes General：Apache Commons 必备。必须使用 3.0 以上版本。Guava 是 Google 推出的产品，新鲜的功能更多一些。 JSON：Jackon功能强大。 XML：据说 JDK 自带的 JAXB 就很好。 Email：直接用 Spring 的封装。 Logging：Slf4j + Log4j + Scribe + Kafka。新同学掌握 Slf4j 和 Log4j 就好。 Schedule：使用 Spring 的 Schedule。Spring Cook Book 部分有演示代码。 时间日期：JodaTime。请看我们的代码示例自学。 io：简单的文件 io 用 apache commons 或者 google guava。zip 文件处理用 zip4j。 读取命令行参数：JCommander是一个简单好用的命令行参数解析框架。 Test Spring测试框架：Spring Test 配合 JUnit 非常顺畅，需要确认项目中使用 Spring 版本 3.0 以上版本。 Mock：Mockito 是现在最优雅简洁的 mock 框架了，强烈推荐使用。Mockito 搞不定的部分，比如static 函数，搭配 PowerMock。 数据库测试：使用 H2 Database 内存数据库。还是怕慢？用 maven-surefire-plugin 多线程执行测试任务。 功能测试：在 onebox 环境测试，一遍遍发布部署太麻烦，使用 jetty-maven-plugin，一键就可以把服务启动起来。 Performance/Stability Test：Jmeter 是成熟的工具。 Development Environment JDK：线上大多数项目使用 JDK6，JDK8 版本会从离线服务开始用，Maven 编译的包需要保证 JDK6 源码与二进制兼容。 版本控制：用 Git，先阅读我们的 Git 文档。如果想深入了解Git，推荐阅读《Git权威指南》。 构建工具：用 Maven。需要熟练掌握以下技巧：1.使用 Maven 打包，比如 Jar、War、Jar with dependency、distribution 包；2.使用 Maven 发布包；3.熟知 Maven依赖管理原理。推荐阅读《Maven权威指南》。 应用服务器：Nginx + Resin，Nginx 作为反向代理，Resin 承担应用服务器和 Java 容器的角色。需要注意，线上服务记得要调优 JVM，线程数等参数。测试环境用 Jetty 插件就好。 查看原文 ","link":"https://blog.coolcode.dev/post/20160102-12-服务端技术选型/"},{"title":"服务端工程师入门与进阶 Java 版","content":"前言 欢迎加入我们。这是一份针对实习生/毕业生的服务端开发入门与进阶指南。遇到问题及时问你的 mentor 或者直接问我。 建议： 尽量用google查找技术资料。 有问题在stackoverflow找找，大部分都已经有人回答。 多看官方的技术文档。 ibm developerworkers的文章质量整体上有保障。 平时花一些时间在github上阅读优秀项目源码。 入门（1-2 个月） 目标：参与简单的项目开发。 技能： 掌握 Java。经典的《Java 核心技术：卷1 基础知识》(或者《Java 编程思想》)必看，跳过其中的图形和 applet 章节。习惯通过 Java API Doc。为了保证代码的质量，《Effective Java》、《Clean Code》和《重构》也需要至少通读一遍。 熟悉 Linux 开发环境和 bash shell。Linux 是我们的开发和部署环境，你最好尽快熟练它。Linux 的基本使用可以通过《鸟哥的Linux私房菜：基础学习篇（第三版）》学习，开发 bash shell 脚本可以参考《Linux Shell脚本攻略》。 掌握开发工具 熟练使用一种 IDE。Intellij IDEA或者 Eclipse 都可以，推荐使用前者。至少熟悉常用的快捷键，会 debug(包括远程 debug)项目。 熟悉一种编辑器。比如 Vim/Emacs，至少学会搜索/替换/代码补全。 掌握 JDK 以外的常用类库和工具包。JDK 原生 API 在很多场景下使用并不方便。你需要掌握社区贡献的优秀类库和工具包，比如 apache commons、google guava 等，具体可以翻阅《技术选型手册》的Utility 篇。 掌握 Web 开发框架。我们使用 Spring(或Rose) + Ibatis(或Jade) 开发 web 服务，你需要熟练掌握它们。 学习代码规范。我们大致上遵循 oracle 的 Java 语言编码规范，你可以先阅读并熟悉它。Code Formatting 文件在 git@git.x.xx.com:xiaomi-commons/coding-standard.git，在编写代码之前，请把它导入到 IDE 中。另外，确认 IDE 已经安装 Findbugs 和 CheckStyle 插件。 熟悉开发流程。我们的开发流程大致如下：功能开发-&gt;单元测试-&gt;功能测试-&gt;Code Review-&gt;集成测试-&gt;发布。确保你熟悉其中的每个环节。 其他。需要熟练使用版本控制工具 Git（阅读：《Git 权威指南》），以及项目构建工具 Maven（阅读：《Maven实战》）。另外，在这个阶段可以尝试 TDD 开发。 进阶（2-6 个月） 目标：独立负责某个服务端项目。 技能： 掌握 web 开发最佳实践，掌握 Restful API 设计，理解 Spring 原理。推荐阅读《Spring 揭秘》。掌握项目分层、子模块划分。推荐阅读：《J2EE 核心模式》。 掌握 web 架构设计。包括 Http 反向代理，数据缓存，负载均衡，水平扩展和垂直扩展。推荐阅读：《分布式Java应用：基础与实践》。 掌握关系型数据库。包括设计 MySQL 表结构，根据业务特点分表分库，基于执行计划的 SQL 分析优化，以及数据库容量规划。推荐阅读：《MySQL 必知必会》、《高性能 MySQL》。 了解 NoSQL。我们大规模使用 Hadoop、HBase、Hive，同时部分项目使用 Redis、Storm。你需要学会这些工具最基本的使用。 学习 web 安全知识。了解 web 前端安全问题。设计安全 web 服务，包括加解密、防伪造、防重放攻击等。 掌握 Http(推荐阅读：《图解 Http》、《Http 权威指南》)、Thrift 等协议。 掌握服务容量规划，性能调优，可靠性保证，以及故障处理。学习容量规划和性能调优知识，梳理业务监控点，熟练使用我们的监控报警系统。推荐阅读：《深入理解 Java 虚拟机》。 其他。设计模式：从项目中学习，有时间可以看看《深入浅出设计模式》、《JDK 里的设计模式》。学习Java Socket 编程与多线程知识，可以看看《Java 并发编程实战》，并翻翻并发编程网的文章。 深入（6 个月-） 目标：分布式系统和中间件开发。 构建知识体系：《大型网站系统与 Java 中间件实践》、《大型网站技术架构：核心原理与案例分析》。 原理与设计：《大规模存储式系统》、《UNIX 网络编程 卷1:套接字联网 API》、《How Tomcat Works》。 学习开源项目：Apache Thrift、Zipkin、Netty、Rose、Jade、淘宝 RPC 系统 Dubbo 等。分析项目中的设计思路。比如，同样是RPC框架，Finagle 和 Dubbo 有什么异同。 其他。根据参与的项目加深学习吧。比如，如果需要写 DSL，可以读一下《领域特定语言》，对 Redis 感兴趣推荐读一下：《Redis 设计与实现》。有两本书，无论做什么项目，都推荐读：《Unix 编程艺术》、《UNIX 环境高级编程(第3版)》。 查看原文 ","link":"https://blog.coolcode.dev/post/20160102-11-服务端工程师入门与进阶 Java 版/"},{"title":"Mac下同时安装多个版本的JDK","content":"JDK8 GA之后，小伙伴们喜大普奔，纷纷跃跃欲试，想体验一下Java8的Lambda等新特性，可是目前Java企业级应用的主打版本还是JDK6， JDK7。因此，我需要在我的电脑上同时有JDK8，JDK7，JDK6。JDK6和JDK7主要是做一些产品代码的验证，以及自己玩一些开源项目，JDK8则纯属尝鲜，谁叫咱是喜新厌旧的程序员呢。 目标 在命令行下，可以通过命令'jdk6', 'jdk7','jdk8'轻松切换到对应的Java版本， 默认初始设置为jdk7。 做法 首先安装所有的JDK： Mac自带了的JDK6，安装在目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/下。 JDK7，JDK8则需要自己到Oracle官网下载安装对应的版本。自己安装的JDK默认路径为：/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk 在用户目录下的bash配置文件.bashrc中配置JAVA_HOME的路径： export JAVA_6_HOME=/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home export JAVA_7_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0.jdk/Contents/Home export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home export JAVA_HOME=$JAVA_7_HOME 创建alias命令动态切换JAVA_HOME的配置 alias jdk8='export JAVA_HOME=$JAVA_8_HOME' alias jdk7='export JAVA_HOME=$JAVA_7_HOME' alias jdk6='export JAVA_HOME=$JAVA_6_HOME' 验证 CNxnliu:Versions xnliu$ java -version java version &quot;1.6.0_65&quot; Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609) Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode) CNxnliu:Versions xnliu$ jdk8 CNxnliu:Versions xnliu$ java -version java version &quot;1.8.0&quot; Java(TM) SE Runtime Environment (build 1.8.0-b132) Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode) CNxnliu:Versions xnliu$ ","link":"https://blog.coolcode.dev/post/20160102-10-Mac下同时安装多个版本的JDK/"},{"title":"受用不尽的Gradle使用方法与技巧","content":"原文：http://geek.csdn.net/news/detail/48955 Gradle尽管比Android Studio早出现，但直到成了官方IDE之后，Gradle才逐渐流行起来。然而，我们是否将这个强大的自动化构建系统的优势发挥地淋漓尽致了呢？ 项目与build的特定全局变量 用gradle可以自动生成BuildConfig类，其中能够生成附加字段。这对配置服务器URL之类的工作十分有用，使用它也能轻松开启或关闭功能。 defaultConfig { buildConfigField &quot;String&quot;, &quot;TWITTER_TOKEN&quot;, '&quot;SDASJHDKAJSK&quot;' } buildTypes { debug { buildConfigField &quot;String&quot;, &quot;API_URL&quot;, '&quot;http://api.dev.com/&quot;' buildConfigField &quot;boolean&quot;, &quot;REPORT_CRASHES&quot;, &quot;true&quot; } release { buildConfigField &quot;String&quot;, &quot;API_URL&quot;, '&quot;http://api.prod.com/&quot;' buildConfigField &quot;boolean&quot;, &quot;REPORT_CRASHES&quot;, &quot;false&quot; } } 可以从BuildConfig的final类BuildConfig.TWITTER_TOKEN，BuildConfig.REPORT_CRASHES与BuildConfig.API_URL进行访问，后两个根据所在的build类不同也会有差异。 每个buildtype的名字、版本与app id都不同 这样一来使用者就能同时安装发布版与debug版了（切记，在安卓系统中无法安装同名的不同应用）。用户可以在崩溃报告工具中以不同的版本名筛选问题与崩溃。通过查看应用名很容易找到目前所运行的版本。 android { buildTypes { debug { applicationIdSuffix &quot;.debug&quot; versionNameSuffix &quot;-debug&quot; resValue &quot;string&quot;, &quot;app_name&quot;, &quot;CoolApp (debug)&quot; signingConfig signingConfigs.debug } release { resValue &quot;string&quot;, &quot;app_name&quot;, &quot;CoolApp&quot; signingConfig signingConfigs.release } } 隐私信息 在Android系统中，所有应用都必须经过证书数字签名才能安装，以便系统能够识别应用的作者。而其中有些属于敏感信息，不应被别人看到。 使用者永远不该将这类信息check in到源代码管理工具中。 有些人主张，每个人都应当有自己的本地配置文件，甚至用全局的~/.gradle/build.gradle，不过如果你要执行持续集成（CI）或部署，特别是没有自己CI服务器的情况下，不应在CVS系统里存放任何类型的纯文本凭证。 signingConfigs { release { storeFile &quot;${System.env.COOL_APP_PRIVATE_KEY}&quot; keyAlias &quot;${System.env.COOL_APP_ALIAS}&quot; storePassword &quot;${System.env.COOL_APP_STORE_PW}&quot; keyPassword &quot;${System.env.COOL_APP_PW}&quot; } } 因此，可以通过环境变量将敏感信息提供给自己的持续集成服务器，而无需担心将任何“危险”信息check in到公司了。 自动生成版本名称（versionName）与版本号（versionCode） 将你的版本拆分成逻辑组件，分别管理。不用再考虑版本号修改的是否正确，也不用担心版本名更新的是否合适了。 def versionMajor = 1 def versionMinor = 0 def versionPatch = 0 android { defaultConfig { versionCode versionMajor * 10000 + versionMinor * 100 + versionPatch versionName &quot;${versionMajor}.${versionMinor}.${versionPatch}&quot; } } 给BuildConfig增加git hash与build时间 def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim() def buildTime = new Date().format(&quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, TimeZone.getTimeZone(&quot;UTC&quot;)) android { defaultConfig { buildConfigField &quot;String&quot;, &quot;GIT_SHA&quot;, &quot;\\&quot;${gitSha}\\&quot;&quot; buildConfigField &quot;String&quot;, &quot;BUILD_TIME&quot;, &quot;\\&quot;${buildTime}\\&quot;&quot; } } 现在有两个可用变量：BuildConfig.GIT_SHA和BuildConfig.BUILD_TIME，用来结合日志与提交信息或者build时间再好不过。 扣紧安全带 想要快速完成部署，只需创建dev类型，将minSdkVersion设定为21。注意：这样做的话，就无法获得针对真实minSdk的合适linting了。因此很明显只能用在日常工作中，而不能用在发布时。这样一来，安卓gradle插件可以将应用程序的每个模块构建为不同的dex文件（pre-dex），并生成可以在Android Lollipop及以上系统中测试的APK包，而无需再耗费大量时间进行dex合并进程。 android { productFlavors dev { minSdkVersion 21 } prod { // The actual minSdkVersion for the application. minSdkVersion 14 } } 直接将单元测试结果输出到console中 使用这个小技巧，我们可以实时看到安卓单元测试的记录结果。 android { ... testOptions.unitTests.all { testLogging { events 'passed', 'skipped', 'failed', 'standardOut', 'standardError' outputs.upToDateWhen { false } showStandardStreams = true } } } 现在运行测试时，输出结果如下： Gradle，tell me I’m pretty 全部放在一起的话，顺序如下： android { ... buildTypes { def BOOLEAN = &quot;boolean&quot; def TRUE = &quot;true&quot; def FALSE = &quot;false&quot; def LOG_HTTP_REQUESTS = &quot;LOG_HTTP_REQUESTS&quot; def REPORT_CRASHES = &quot;REPORT_CRASHES&quot; def DEBUG_IMAGES = &quot;DEBUG_IMAGES&quot; debug { ... buildConfigField BOOLEAN, LOG_HTTP_REQUESTS, TRUE buildConfigField BOOLEAN, REPORT_CRASHES, FALSE buildConfigField BOOLEAN, DEBUG_IMAGES, TRUE } release { ... buildConfigField BOOLEAN, LOG_HTTP_REQUESTS, FALSE buildConfigField BOOLEAN, REPORT_CRASHES, TRUE buildConfigField BOOLEAN, DEBUG_IMAGES, FALSE } } } ","link":"https://blog.coolcode.dev/post/20160101-7-受用不尽的Gradle使用方法与技巧/"},{"title":"JAVA虚拟机之一：垃圾回收（GC）机制","content":"原文: http://alaric.iteye.com/blog/2262566 引言 java对于其它语言（c/c++）来说，创建一个对象使用后，不用显式的delete/free，且能在一定程度上保证系统内存资源及时回收，这要功归于java的自动垃圾回收机制（Garbage Collection，GC），但也是因为自动回收机制存在，一旦系统内泄漏或存溢出时，排查问题比较困难，因此java程序开发者深入理解java虚拟机GC机制变得重要。 要掌握GC机制，需要搞清楚下面几个问题： 运行时有哪些内存区域？ 运行时怎么给类、对象分配内存？ 哪些区域的内存需要回收？ 内存中的哪些对象可以回收？ 如何回收？ 一、运行时有哪些内存区域？ 根据java虚拟机规范规定，java虚拟机所管理的运行时内存包括以下区域，如下图： 程序计数器：每一条java线程都有一个独立的程序计数器，我们把线程相互独立隔离的区域叫线程私有的，它的作用可以看作是当前线程所执行的字节码的行号指示器，它是一块较小的空间区域，如果执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码的指令地址，如果是native的方法，这个计数器的值为空（undefined）。 java虚拟机栈：java虚拟机栈与程序计数器一样，也是一条线程私有的，java虚拟机栈描述的是java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链路，方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈：本地方法栈和虚拟机栈作用非常相似，不同的是java虚拟机栈是为执行的是java方法服务的，而本地方法栈是为native的方法执行服务的。 java堆：java堆（heap）是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都要在堆上分配内存。在堆上的内存是分代管理的，分为新生代和老年代，新生代又细分为：Eden，From Survivor，To Survivor，它们空间大小比例为8:1:1。 方法区：方法区与java堆一样，是各个线程共享的内存区域，它用用于存储已被虚拟机加载的类信息，常量，静态变量、即时编译器编译后的代码等数据。虽然java虚拟机规范把方法区描述为堆得一个逻辑部分，但是它却有一个别名叫Non-Heap（非堆），目的应该是与java堆区分开来，也称“永久代”（Permanent Generation）。hotspot虚拟机永久代已经完全在JDK 8移除，用Native Memory来的实现，命名为metaSpace，https://blogs.oracle.com/poonam/entry/about_g1_garbage_collector_permanent。在下图左右是分别是jdk6，jdk8中jvisualvm的运行时数据内存的监控。 运行时常量池：运行时常量池是方法区的一部分。用于存放编译期生成的各种字面量和符号引用。 二、运行时怎么给类、对象分配内存？ 要了解java垃圾回收机制前必须知道java怎么分配给对象内存的，根据上面运行时数据区域的划分可以知道，几乎所有的对象都在堆上分配，而类信息、常量、静态变量在方法区分配。堆内存是分代管理的，对象优先在Eden分配；大对象（所谓的大对象是指需要连续内存空间的java对象，如很长的字符串或者数组）直接进入老年代；长期存活的对象将进入老年代，在垃圾回收时在Survivor中每熬过一次youngGC，他的年龄就增加1，直到到达指定的年龄就会被放入老年代。 三、那些区域的内存需要回收？ 根据运行时数据区域的各个部分，程序计数器、虚拟机栈、本地方法栈三个区域随着线程而生，随线程灭而灭。栈中的栈帧随着方法的进入和退出而进栈出栈。每个栈帧分配多少内存在类结构确定下来的时候就基本已经确定。所以这个三个区域内存回收时方法或者线程结束而回收的，不需要太多关注；而java堆和方法区则不一样，一个接口不同实现类，一个方法中不同的分支，在具体运行的时候才能确定创建那些对象，所以这部分内存是动态的，也是需要垃圾回收机制来回收处理的。 四、内存中的哪些对象可以回收？ 堆内存：判断堆内的对象是否可以回收，要判断这个对象实例是否确实没用，判断算法有两种：引用计数法和根搜索算法。引用计数法：就是给每个对象加一个计数器，如果有一个地方引用就加1，当引用失效就减1；当计数器为0，则认为对象是无用的。这种算法最大的问题在于不能解决相互引用的对象，如：A.b=B;B.a=A，在没有其他引用的情况下，应该回收；但按照引用计数法来计算，他们的引用都不为0，显然不能回收。根搜索算法：这个算法的思路是通过一系列名为“GC Roots”的对象作为起点，从这个节点向下搜索，搜索所经过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连(图论的不可达)时，则证明该对象不可用。java等一大部分商用语言是用根搜索算法来管理内存的，java中可以做为GC Roots的对象有如下几种：- 虚拟机栈（栈帧中的本地变量表）中的引用的对象； 方法区中的类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈JNI(Native)的引用对象； 方法区：方法区回收主要有两部分：废弃的常量和无用的类。废弃的常量判断方法和堆中的对象类似，只要判断没有地方引用就可以回收。相比之下，判断一个类是否无用，条件就比较苛刻，需要同事满足下面3个条件才能算是“无用的类”：- 该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对于满足上面三个条件的无用类进行回收，仅仅是可以回收，具体能否回收，JVM提供了-Xnoclassgc参数进行控制。 五、如何回收？ gc有多种算法，根据不同的算法实现了不同的垃圾回收器，每种收集器在可以在不同的应用场景使用。 回收算法：- 标记-清除（Mark-Sweep）算法：如它的名字一样，算法分“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉被标记的对象。主要有两个缺点：一个是效率问题，标记和清除效率都不高；另一个是空间问题：标记清除后会产生大量空间碎片。 复制（Copying）算法：它将内存按容量分成大小相等的两块，每次只用一块，当这一块内存用完后，就将可用的对象复制到另外一块上面，然后一次性清除已用过那块的内存空间。优点是实现简单，运行效率高，缺点是内存缩小为原来的一半。 标记整理（Mark-Compact）算法：此算法仍然与标记-清除算法一样，第一步标记，第二步不是对无用对象清理，而是，让所有可用对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法的优点是不会产生空间碎片。 分代收集（Generation Collection）算法：分代收集算法根据对象存活周期的不同将内存划为几块，一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。在新生代中，每次垃圾回收时都发现大批对象死去，只有少量存活，那就选用复制算法，付出少量复制成本就可以完成收集。而老年代中对象存活率较高且没有空间进行担保（后面讲新生代的担保分配），就必须使用“标记-清除”或者“标记-整理”算法。 垃圾回收器，垃圾回收器是垃圾回收算法的具体实现，一般不同的厂商或者不同版本的虚拟机都包含不同的垃圾收集器，并且一般会提供参数供用户选择在不用业务场景下组合出各个年代所使用的收集器。Hotspot虚拟机包含垃圾收集器如下图: Serial(串行GC)收集器 ：Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。 ParNew(并行GC)收集器 ：ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。 Parallel Scavenge(并行回收GC)收集器 ：Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 Serial Old(串行GC)收集器 ：Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。 Parallel Old(并行GC)收集器 ：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 CMS(并发GC)收集器 ：CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤： 初始标记(CMS initial mark) 并发标记(CMS concurrenr mark) 重新标记(CMS remark) 并发清除(CMS concurrent sweep) 其中初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以整体来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，器主要有三个显著缺点：CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，即需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分内存空间提供并发收集时的程序运作使用。在默认设置下，CMS收集器在老年代使用了68%的空间时就会被激活，也可以通过参数-XX:CMSInitiatingOccupancyFraction的值来提供触发百分比，以降低内存回收次数提高性能。要是CMS运行期间预留的内存无法满足程序其他线程需要，就会出现“Concurrent Mode Failure”失败，这时候虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置的过高将会很容易导致“Concurrent Mode Failure”失败，性能反而降低。最后一个缺点，CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full GC之后，跟着来一次碎片整理过程。 G1收集器：在G1中，堆被划分成 许多个连续的区域(region)。每个区域大小相等，在1M~32M之间。JVM最多支持2000个区域，可推算G1能支持的最大内存为2000*32M=62.5G。区域(region)的大小在JVM初始化的时候决定，也可以用-XX:G1HeapReginSize设置。在G1中没有物理上的Yong(Eden/Survivor)/Old Generation，它们是逻辑的，使用一些非连续的区域(Region)组成的。 垃圾收集（Garbage Collection），新生代的GC叫YongGC，也叫MinorGC，指发生在新生代的垃圾回收动作，因为java具备朝生夕灭特性，所以YongGC非常频繁，一般回收集比较快；老年代GC叫FullGC，也叫Major GC，一般都伴有YongGC，GC的速度一般比YongGC慢10倍以上。目前虚拟机实现都是分代收集(G1物理上是不连续的，是逻辑分代，这里主要以jdk1.7之前为例)，当要给对象分配空间时，在Eden上分配空间，如果空间不够，则触发一次YongGC，如果空间够，则分配空间，如果还不够则直接进入老年代；当一次YongGC后，从Eden，From Survivor的对象放入To Survivor，如果放不下，则进入老年代；每次Yong GC 后还留在Survivor中的对象，对象的年龄Age加1，达到一定年龄（默认为15，可用参数-XX:MaxTenuringThreshold设置）后自动进入老年代；在发生Yong GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于则看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。 总结： java GC主要主要指java堆和方法区的对象回收，哪些对象可以回收是通过根搜索算法来判断的，在堆中是分代收集的，怎么回收是由具体的垃圾收集器来完成的，在不同的应用场景下，开发者可以选择不同的收集器来满足业务需求，达到最佳性能。 参考资料： 深入理解java虚拟机-周志民 The Java® Virtual Machine Specification Java SE 8 Edition ","link":"https://blog.coolcode.dev/post/20160101-6-JAVA虚拟机之一：垃圾回收（GC）机制/"},{"title":"有了tldr，妈妈再也不用担心我记不住命令了","content":"原文: http://codingstyle.cn/topics/26 引言 有一次我在培训时说「程序员要善于使用 Terminal 以提高开发效率」，一位程序员反驳道：「这是 21 世纪，我们为什么要用落后的命令行，而不是先进的 GUI？」 是的，在一些人眼里，这个黑黑的终端窗口代表着确实代表着落后，装B。 而在另一些人手里，它却是一个高效的工具。 其实很多人觉得 Terminal 难用，他们认为： 命令很多，难记 敲命令很麻烦 界面黑黑的，难看 ... 可能这些印象都来自于「未经任何武装」的 Terminal，实际上始终有一部分人是 Terminal 忠实用户，他们也在推动着 Terminal 与日俱增。 所以，接下来我准备分享一系列使用 Terminal 的技巧。 目录 别再用 CD 切换目录了 「What the fuck」妈妈再也不用担心我敲错命令了 正文 使用 Terminal 最难的就是要叫住众多的 Linux 命令了，比如：ssh，curl，grep等，经常会记不住参数的顺序。 今天要介绍的工具叫：tldr。 在很多地方都会看到：「tl;dr」或「TL;DR」。 它的意思是「Too long, Don't read」，翻译成中文就是：「太长不读」。 我们可以使用man或者--help来查看特定命令的用法，但读起来效率很低。 tldr 根据「二八原则」原理，将命令的常用「场景」给出示例，让人一看就懂。 来看几个例子吧： 怎么样，比man看起来舒服多了吧？ 安装 安装也很简单，各种包管理工具都支持。 还等什么，赶紧上手体验一下吧！ ","link":"https://blog.coolcode.dev/post/20151230-5-有了tldr妈妈再也不用担心我记不住命令了/"},{"title":"由字符串反转(使用递归)引申出来一道Java面试题","content":"如何面试一个从事编程工作的开发人员既困难又乏味，幸好还有很多值得参考的指南，比如：《Joel Guerilla Guide to interviewing》，但最后雇佣与否，还得由你自己决定。为了快速地了解他们的编程能力，我想到了一个关于字符串反转的问题，有人用这道题取得不错的效果，这道题的答案有很多种，因此这给了你足够的空间去考察候选者的技能，我自己思考了会儿，找到好几种答案如何用Java实现字符串的反转。候选者的答案正好是面试官了解他们如何思考的一种方式。你可以用相关的接口来定义这道题，里面有一个未实现的方法。 public interface Reverser { public String reverse(String str); } 在Java中，最好的实现就是用JDK中StringBuffer的反转方法，它不仅速度快，效率高，而且还知道如何处理unicode代理对(surrogate pairs)。其它方案基本上都可以忽略掉。 public class JdkReverser implements Reverser { public String reverse(String str) { if ((null == str) || (str.length() &lt;= 1)) { return str; } return new StringBuffer(str).reverse().toString(); } } 不仅选择把趣味性地实现当做一种答案，而且候选者有没有重用JDK，或者告诉你“JDK中有那么些东西是可以去实现的”，哪一种好呢，google一下可以帮你找到JDK的解决方案，你总不希望开发者实现一切。 处理问题： 问他代码中什么地方有bug，即使没有。或者代码怎么会报错，他的答案至少可以引出一个讨论关于如何处理空值的话题来。 返回null 返回“” 抛出NullPointerException 抛出IllegalArgumentException 第二个讨论的焦点是是如何去优化解决方法，像返回字符串本省“”,长度为1的字符串（本省就是反转） 递归（Recursion)： 之后要求应聘者在反转的问题上写一个递归的方案（这至少是漂亮的，但至少可用） public String reverse(String str) { if ((null == str) || (str.length() &lt;= 1)) { return str; } return reverse(str.substring(1)) + str.charAt(0); } 有些开发人员在脑海中想不到处理递归，或者需要时间和一些提示。那些不能处理递归的很有可能对于复杂的问题没法完成。 你可以问他们关于递归方案的效率，询问尾(Tail)递归，询问 “+”操作的效率，如何处理，关于为什么String都是不可变的（至少在大多时候这么问），反转“Stephan”时，问候选者有多少个字符串对象创建。在讨论中，开发者说“Easy”，他在整个大学都在用Lisp语言，之前我还不知道，现在听起来真是个极好的消息。你还可以询问在上面代码结束递归的停止条件。 更多的方案： 在适当的位置调动StringBuffer： public String reverse(String str) { if ((null == str) || (str.length() &lt;= 1 )) { return str; } StringBuffer result = new StringBuffer(str); for (int i = 0; i &lt; (str.length() / 2); i++) { int swapIndex = str.length() - 1 - i; char swap = result.charAt(swapIndex); result.setCharAt(swapIndex, result.charAt(i)); result.setCharAt(i, swap); } return result.toString(); } 采用调用数组的方法： public String reverse(String str) { if ((null == str) || (str.length() &lt;= 1)) { return str; } char[] chars = str.toCharArray(); int right = chars.length - 1; for (int left = 0; left &lt; right; left++) { char swap = chars[left]; chars[left] = chars[right]; chars[right--] = swap; } return new String(chars); } SringBuffer追加的方法： public String reverse(String str) { if ((null == str) || (str.length() &lt;= 1)) { return str; } StringBuffer reverse = new StringBuffer(str.length()); for (int i = str.length() - 1; i &gt;= 0; i--) { reverse.append(str.charAt(i)); } return reverse.toString(); } } 也许候选人还知道棘手的XOR swapping solution方法。 这是一个开放性的领域，你可以要求候选者写一个JUnit 测试它的反转方法，这样不仅可以展现他写测试单元的能力，而且作为测试用例，他所考虑的条件(“”,null，”A”，奇数长度的字符串，偶数长度的字符串,….） 在你决定是否雇用时，希望以上能帮上你，对自己来说，在将来的某个时候希望同样可以我帮助到自己，就像Joel说的：“疑人不用，用人不疑（when in doubt ,always no hire)。” 英文原文：Codemonkeyism，编译：ImportNew - 刘志军 译文链接： http://www.importnew.com/501.html ","link":"https://blog.coolcode.dev/post/20151229-4-由字符串反转(使用递归)引申出来一道Java面试题/"},{"title":"【译】Stackoverflow：Java Servlet 工作原理问答","content":"导读 本文来自stackoverflow的问答，讨论了Java Servlet的工作机制，如何进行实例化、共享变量和多线程处理。 问题：Servlet 是如何工作的？Servlet 如何实例化、共享变量、并进行多线程处理？ 假设我有一个运行了大量&nbsp;Servlet&nbsp;的 web 服务器。通过&nbsp;Servlet&nbsp;之间传输信息得到&nbsp;Servlet&nbsp;上下文，并设置 session 变量。 现在，如果有两名或更多使用者向这个服务发送请求，接下来 session 变量会发生什么变化？究竟是所有用户都是用共同的变量？还是不同的用户使用的变量都不一样？如果是后者，服务器如何区分不同用户？ 另一个相似的问题，如果有&nbsp;*n*&nbsp;名用户访问一个特定的&nbsp;Servlet，那么该&nbsp;Servlet&nbsp;是仅在第一个用户首次访问的时候实例化，还是分别为每个用户实例化？ 回答（BalusC）： ServletContext 当 Servlet 容器（比如&nbsp;Apache Tomcat）启动后，会部署和加载所有 web 应用。当web 应用被加载，Servlet 容器会创建一次&nbsp;ServletContext，然后将其保存在服务器的内存中。web 应用的&nbsp;web.xml&nbsp;被解析，找到其中所有&nbsp;servlet、filter&nbsp;和&nbsp;Listener&nbsp;或&nbsp;@WebServlet、@WebFilter&nbsp;和&nbsp;@WebListener&nbsp;注解的内容，创建一次并保存到服务器的内存中。对于所有过滤器会立即调用&nbsp;init()。当 Servlet 容器停止，将卸载所有 web 应用，调用所有初始化的 Servlet 和过滤器的&nbsp;destroy()&nbsp;方法，最后回收&nbsp;ServletContext&nbsp;和所有&nbsp;Servlet、Filter 与&nbsp;Listener&nbsp;实例。 当问题中的&nbsp;Servlet&nbsp;配置的&nbsp;load-on-startup&nbsp;或者&nbsp;@WebServlet(loadOnStartup)&nbsp;设置了一个大于 0 的值，则同样会在启动的时候立即调用&nbsp;init()&nbsp;方法。&ldquo;load-on-startup&rdquo;中的值表示那些 Servlet 会以相同顺序初始化。如果配置的值相同，会遵循&nbsp;web.xml&nbsp;中指定的顺序或@WebServlet&nbsp;类加载的顺序。另外，如果不设置 &ldquo;load-on-startup&rdquo; 值，init()&nbsp;方法只在第一次 HTTP 请求命中问题中的 Servlet 时才被调用。 HttpServletRequest 与 HttpServletResponse Servlet 容器附加在一个 web 服务上，这个 web 服务会在某个端口号上监听 HTTP 请求，在开发环境中这个端口通常为 8080，生产环境中通常为 80。当客户端（web 浏览器）发送了一个 HTTP 请求，Servlet 容器会创建新的&nbsp;HttpServletRequest&nbsp;和&nbsp;HttpServletResponse&nbsp;对象，传递给已创建好并且请求的 URL 匹配&nbsp;url-pattern&nbsp;的&nbsp;Filter&nbsp;和&nbsp;Servlet&nbsp;实例中的方法，所有工作都在同一个线程中处理。 request 对象可以访问所有该 HTTP 请求中的信息，例如 request header 和 request body。response 对象为你提供需要的控制和发送 HTTP 响应方法，例如设置 header 和 body（通常会带有 JSP 文件中的 HTML 内容）。提交并完成HTTP 响应后，将回收 request 和 response 对象。 HttpSession 当用户第一次访问该 web 应用时，会通过&nbsp;request.getSession()&nbsp;第一次获得&nbsp;HttpSession。之后 Servlet 容器将会创建&nbsp;HttpSession，生成一个唯一的 ID（可以通过&nbsp;session.getId()&nbsp;获取）并储存在服务器内存中。然后 Servlet 容器在该次 HTTP 响应的&nbsp;Set-Cookie&nbsp;头部设置一个Cookie，以&nbsp;JSESSIONID&nbsp;作为 Cookie 名字，那个唯一的 session ID 作为&nbsp;Cookie&nbsp;的值。 按照&nbsp;HTTP cookie 规则（正常 web 浏览器和 web 服务端必须遵循的标准），当 cookie 有效时，要求客户端（浏览器）在后续请求的&nbsp;Cookie&nbsp;头中返回这个 cookie。使用浏览器内置的 HTTP 流量监控器，你可以查看它们（在 Chrome、Firefox23+、IE9+ 中按 F12，然后查看 Net/Network 标签）。Servlet 容器将会确定每个进入的 HTTP 请求的&nbsp;Cookie&nbsp;头中是否存在名为JSESSIONID&nbsp;的 cookie，然后用它的值（session ID）从服务端内存中找到关联的&nbsp;HttpSession。 你可以在&nbsp;web.xml&nbsp;中设置&nbsp;session-timeout&nbsp;，默认值为 30 分钟。超时到达之前&nbsp;HttpSession会一直存活。所以当客户端不再访问该 web 应用超过 30 分钟后，Servlet 容器就会回收这个 session。后续每个请求，即使指定 cookie 名称也不能再访问到相同的 session。Servlet 容器会创建一个新的&nbsp;Cookie。 另一方面，客户端上的 session cookie 有一个默认存活时间，该事件和该浏览器实例运行时间一样长。所以，当客户端关闭该浏览器实例（所有标签和窗口）后，这个 session 就会被客户端回收。新浏览器实例不再发送与该 session 关联的 cookie。一个新的&nbsp;request.getSession()&nbsp;将会返回新的&nbsp;HttpSession&nbsp;并设置一个拥有新&nbsp;session&nbsp;ID 的 cookie。 概述 ServletContext&nbsp;与 web 应用存活时间一样长。它被所有 session 中的所有请求共享。 只要客户端一直与相同浏览器实例的web应用交互并且没有超时，HttpSession就会存在。 HttpServletRequest&nbsp;和&nbsp;HttpServletResponse&nbsp;的存活时间为客户端发送完成到完整的响应（web 页面）到达的这段时间。不会被其他地方共享。 所有 Servlet、Filter&nbsp;和&nbsp;Listener&nbsp;对象在 web 应用运行时都是活跃的。它们被所有 session 中的请求共享。 你设置在&nbsp;HttpServletRequest、HttpServletResponse&nbsp;和&nbsp;HttpSession&nbsp;中的所有属性在问题中的对象存活时都会一直保持存活。 线程安全 即便如此，你最关心的可能是线程安全。你现在应该学习到 Servlet 和 filter 被所有请求共享。那是 Java 的一个优点，使得多个不同线程（读取 HTTP 请求）可以使用同一个实例。否则为每个请求重新创建线程的开销实在过于昂贵。 但你应该也意识到永远不要将任何 request 或 session 域中的数据赋值给 servlet 或 filter 的实例变量。它将会被所有其他 session 中的所有请求共享。那是非线程安全的！下面的示例对这种情况进行了展示： public class ExampleServlet extends HttpServlet { &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;private&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; Object thisIsNOTThreadSafe; &lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;protected&lt;/span&gt; &lt;span style=&quot;color: #0000ff;&quot;&gt;void&lt;/span&gt; doGet(HttpServletRequest request, HttpServletResponse response) &lt;span style=&quot;color: #0000ff;&quot;&gt;throws&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt; ServletException, IOException { Object thisIsThreadSafe; thisIsNOTThreadSafe &lt;/span&gt;= request.setParameter(&quot;foo&quot;); &lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; BAD!! Shared among all requests!&lt;/span&gt; thisIsThreadSafe = request.getParameter(&quot;foo&quot;); &lt;span style=&quot;color: #008000;&quot;&gt;//&lt;/span&gt;&lt;span style=&quot;color: #008000;&quot;&gt; OK, this is thread safe.&lt;/span&gt; } } 请参考： JSF、Servlet 和 JSP 之间有什么不同？ Java 中管理 Session 的最佳选择 Servlet 中的 doGet 与 doPost Servlet 似乎会同步处理多并发请求 &nbsp; &nbsp; 原文链接：stackoverflow\b 首发至：ht\btp://www.importnew.com/17025.html，并已同步至 Github，欢迎 Star 关注。 ","link":"https://blog.coolcode.dev/post/20151229-3-Stackoverflow：Java Servlet 工作原理问答/"},{"title":"Linux TOP命令","content":"原文: http://my.oschina.net/liting/blog/551284 TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。 TOP是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定. top - 12:38:33 up 50 days, 23:15, 7 users, load average: 60.58, 61.14, 61.22 Tasks: 203 total, 60 running, 139 sleeping, 4 stopped, 0 zombie Cpu(s) : 27.0%us, 73.0%sy, 0.0%ni, 0.0%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 1939780k total, 1375280k used, 564500k free, 109680k buffers Swap: 4401800k total, 497456k used, 3904344k free, 848712k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 4338 oracle 25 0 627m 209m 207m R 0 11.0 297:14.76 oracle 4267 oracle 25 0 626m 144m 143m R 6 7.6 89:16.62 oracle 3458 oracle 25 0 672m 133m 124m R 0 7.1 1283:08 oracle 3478 oracle 25 0 672m 124m 115m R 0 6.6 1272:30 oracle 3395 oracle 25 0 672m 122m 113m R 0 6.5 1270:03 oracle 3480 oracle 25 0 672m 122m 109m R 8 6.4 1274:13 oracle 3399 oracle 25 0 672m 121m 110m R 0 6.4 1279:37 oracle 4261 oracle 25 0 634m 100m 99m R 0 5.3 86:13.90 oracle 25737 oracle 25 0 632m 81m 74m R 0 4.3 272:35.42 oracle 7072 oracle 25 0 626m 72m 71m R 0 3.8 6:35.68 oracle 16073 oracle 25 0 630m 68m 63m R 8 3.6 175:20.36 oracle 16140 oracle 25 0 630m 66m 60m R 0 3.5 175:13.42 oracle 16122 oracle 25 0 630m 66m 60m R 0 3.5 176:47.73 oracle 786 oracle 25 0 627m 63m 63m R 0 3.4 1:54.93 oracle 4271 oracle 25 0 627m 59m 58m R 8 3.1 86:09.64 oracle 4273 oracle 25 0 627m 57m 56m R 8 3.0 84:38.20 oracle 22670 oracle 25 0 626m 50m 49m R 0 2.7 84:55.82 oracle TOP前五行统计信息 统计信息区前五行是系统整体的统计信息。 第一行是任务队列信息 同 uptime 命令的执行结果: [root@localhost ~]# uptime 13:22:30 up 8 min, 4 users, load average: 0.14, 0.38, 0.25 其内容如下： 12:38:33 当前时间 up 50days 系统运行时间，格式为时:分 1 user 当前登录用户数 load average: 0.06, 0.60, 0.48 系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。 第二、三行为进程和CPU的信息 当有多个CPU时，这些内容可能会超过两行。内容如下： Tasks: 29 total 进程总数 1 running 正在运行的进程数 28 sleeping 睡眠的进程数 0 stopped 停止的进程数 0 zombie 僵尸进程数 Cpu(s): 0.3% us 用户空间占用CPU百分比 1.0% sy 内核空间占用CPU百分比 0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比 98.7% id 空闲CPU百分比 0.0% wa 等待输入输出的CPU时间百分比 0.0% hi 0.0% si 第四五行为内存信息。 内容如下： Mem: 191272k total 物理内存总量 173656k used 使用的物理内存总量 17616k free 空闲内存总量 22052k buffers 用作内核缓存的内存量 Swap: 192772k total 交换区总量 0k used 使用的交换区总量 192772k free 空闲交换区总量 123988k cached 缓冲的交换区总量。 内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖， 该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。 进程信息 PID 进程id PPID 父进程id RUSER Real user name UID 进程所有者的用户id USER 进程所有者的用户名 GROUP 进程所有者的组名 TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 P 最后使用的CPU，仅在多CPU环境下有意义 %CPU 上次更新到现在的CPU时间占用百分比 TIME 进程使用的CPU时间总计，单位秒 TIME+ 进程使用的CPU时间总计，单位1/100秒 %MEM 进程使用的物理内存百分比 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA CODE 可执行代码占用的物理内存大小，单位kb DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb SHR 共享内存大小，单位kb nFLT 页面错误次数 nDRT 最后一次写入到现在，被修改过的页面数。 S 进程状态。 D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 COMMAND 命令名/命令行 WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 Flags 任务标志，参考 sched.h top 的man 命令解释如下： Listed below are top's available fields. They are always associated with the letter shown, regardless of the position you may have established for them with the 'o' (Order fields) interactive command.Any field is selectable as the sort field, and you control whether they are sorted high-to-low or low-to-high. For additional information on sort provisions see topic 3c. TASK Area Commands. a: PID -- Process Id The task's unique process ID, which periodically wraps, though never restarting at zero. b: PPID -- Parent Process Pid The process ID of a task's parent. c: RUSER -- Real User Name The real user name of the task's owner. d: UID -- User Id The effective user ID of the task's owner. e: USER -- User Name The effective user name of the task's owner. f: GROUP -- Group Name The effective group name of the task's owner. g: TTY -- Controlling Tty The name of the controlling terminal. This is usually the device (serial port, pty, etc.) from which the process was started, and which it uses for input oroutput. However, a task need not be associated with a terminal, in which case you'll see '?' displayed. h: PR -- Priority The priority of the task. i: NI -- Nice value The nice value of the task. A negative nice value means higher priority, whereas a positive nice value means lower priority. Zero in this field simply means priority will not be adjusted in determining a task's dispatchability. j: P -- Last used CPU (SMP) A number representing the last used processor. In a true SMP environment this will likely change frequently since the kernel intentionally uses weak affinity. Also, the very act of running top may break this weak affinity and cause more processes to change CPUs more often (because of the extra demand for cpu time). k: %CPU -- CPU usage The task's share of the elapsed CPU time since the last screen update, expressed as a percentage of total CPU time. In a true SMP environment, if 'Irix mode' is Off, top will operate in 'Solaris mode' where a task's cpu usage will be divided by the total number of CPUs. You toggle 'Irix/Solaris' modes with the 'I' interactive command. l: TIME -- CPU Time Total CPU time the task has used since it started. When 'Cumulative mode' is On, each process is listed with the cpu time that it and its dead children has used. You toggle 'Cumulative mode' with 'S', which is a command-line option and an interactive command. See the 'S' interactive command for additional information regarding this mode. m: TIME+ -- CPU Time, hundredths The same as 'TIME', but reflecting more granularity through hundredths of a sec ond. n: %MEM -- Memory usage (RES) A task's currently used share of available physical memory. o: VIRT -- Virtual Image (kb) The total amount of virtual memory used by the task. It includes all code, data and shared libraries plus pages that have been swapped out. (Note: you can define the STATSIZE=1 environment variable and the VIRT will be calculated from the /proc/#/state VmSize field.) VIRT = SWAP + RES. p: SWAP -- Swapped size (kb) The swapped out portion of a task's total virtual memory image. q: RES -- Resident size (kb) The non-swapped physical memory a task has used. RES = CODE + DATA. r: CODE -- Code size (kb) The amount of physical memory devoted to executable code, also known as the'text resident set' size or TRS. s: DATA -- Data+Stack size (kb) The amount of physical memory devoted to other than executable code, also known the 'data resident set' size or DRS. t: SHR -- Shared Mem size (kb) The amount of shared memory used by a task. It simply reflects memory that could be potentially shared with other processes. u: nFLT -- Page Fault count The number of major page faults that have occurred for a task. A page fault occurs when a process attempts to read from or write to a virtual page that is not currently present in its address space. A major page fault is when disk access is involved in making that page available. v: nDRT -- Dirty Pages count The number of pages that have been modified since they were last written to disk. Dirty pages must be written to disk before the corresponding physical memory location can be used for some other virtual page. w: S -- Process Status The status of the task which can be one of: 'D' = uninterruptible sleep 'R' = running 'S' = sleeping 'T' = traced or stopped 'Z' = zombie Tasks shown as running should be more properly thought of as 'ready to run' --their task_struct is simply represented on the Linux run-queue. Even without a true SMP machine, you may see numerous tasks in this state depending on top's delay interval and nice value. x: Command -- Command line or Program name Display the command line used to start a task or the name of the associated program. You toggle between command line and name with 'c', which is both a command-line option and an interactive command. When you've chosen to display command lines, processes without a command line (like kernel threads) will be shown with only the program name in parentheses, as in this example: ( mdrecoveryd ) Either form of display is subject to potential truncation if it's too long to fit in this field's current width. That width depends upon other fields selected, their order and the current screen width. Note: The 'Command' field/column is unique, in that it is not fixed-width. When displayed, this column will be allocated all remaining screen width (up to the maximum 512 characters) to provide for the potential growth of program names into command lines. y: WCHAN -- Sleeping in Function Depending on the availability of the kernel link map ('System.map'), this field will show the name or the address of the kernel function in which the task is currently sleeping. Running tasks will display a dash ('-') in this column. Note: By displaying this field, top's own working set will be increased by over 700Kb. Your only means of reducing that overhead will be to stop and restart top. z: Flags -- Task Flags This column represents the task's current scheduling flags which are expressed in hexadecimal notation and with zeros suppressed. These flags are officially documented in &lt;linux/sched.h&gt;. Less formal documentation can also be found on the 'Fields select' and 'Order fields' screens. 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。 2.1 用快捷键更改显示内容。 （1）更改显示内容通过 f键可以选择显示的内容。 按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。 （2）按o键可以改变列的显示顺序。 按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。 按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。 设置完按回车返回界面。 命令使用 详细内容可以参考MAN 帮助文档。这里列举部分内容： 命令格式： top [-] [d] [p] [q] [c] [C] [S] [n] 参数说明： d： 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 p： 通过指定监控进程ID来仅仅监控某个进程的状态。 q：该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 S： 指定累计模式 s ： 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i： 使top不显示任何闲置或者僵死进程。 c： 显示整个命令行而不只是显示命令名 在top命令的显示窗口，我们还可以输入以下字母，进行一些交互： 帮助文档如下： Help for Interactive Commands - procps version 3.2.7 Window 1:Def: Cumulative mode Off. System: Delay 4.0 secs; Secure mode Off. Z,B Global: 'Z' change color mappings; 'B' disable/enable bold l,t,m Toggle Summaries: 'l' load avg; 't' task/cpu stats; 'm' mem info 1,I Toggle SMP view: '1' single/separate states; 'I' Irix/Solaris mode f,o . Fields/Columns: 'f' add or remove; 'o' change display order F or O . Select sort field &lt;,&gt; . Move sort field: '&lt;' next col left; '&gt;' next col right R,H . Toggle: 'R' normal/reverse sort; 'H' show threads c,i,S . Toggle: 'c' cmd name/line; 'i' idle tasks; 'S' cumulative time x,y . Toggle highlights: 'x' sort field; 'y' running tasks z,b . Toggle: 'z' color/mono; 'b' bold/reverse (only if 'x' or 'y') u . Show specific user only n or # . Set maximum tasks displayed k,r Manipulate tasks: 'k' kill; 'r' renice d or s Set update interval W Write configuration file q Quit ( commands shown with '.' require a visible task display window ) Press 'h' or '?' for help with Windows, h或者? : 显示帮助画面，给出一些简短的命令总结说明。 k ：终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 i：忽略闲置和僵死进程。这是一个开关式命令。 q： 退出程序。 r： 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 S：切换到累计模式。 s : 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f或者F :从当前显示中添加或者删除项目。 o或者O :改变显示项目的顺序。 l: 切换显示平均负载和启动时间信息。即显示影藏第一行 m： 切换显示内存信息。即显示影藏内存行 t ： 切换显示进程和CPU状态信息。即显示影藏CPU行 c： 切换显示命令名称和完整命令行。 显示完整的命令。 这个功能很有用。 M ： 根据驻留内存大小进行排序。 P：根据CPU使用百分比大小进行排序。 T： 根据时间/累计时间进行排序。 W： 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 ","link":"https://blog.coolcode.dev/post/20151229-2-Linux TOP命令/"},{"title":"CentOS v6.7 新装配置","content":"从网上下载到 CentOS-6.7-x86_64-bin-DVD1.iso 完整版，并通过 Mac OSX 上的虚拟机应用 Parallels Desktop 安装 Basic Server后，根据自己的需要进行如下环境的配置： 安装 git 版本控制工具 安装 nvm 和 node.js 安装 nginx 启用网络 但是刚装完的系统，发现无法解析域名，于是输入 ifconfig 来查看网络信息： lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 b) TX bytes:0 (0.0 b) 只有 loopback，看来是网口没有启动，于是我们去到代表我们网口设备的文件 /etc/sysconfig/network-scripts/ifcfg-eth0 （ eth0 代表第一个网口）。 发现其中 ONBOOT 为 false，我们把它该为 true，让它启用这个网口。随后 service network restart 来重启网络服务，待 ip 被分配好后，即可上网。 开始安装 git 先从 git 开始，我们用 yum install git 来快速安装 git，不过查看下版本，是 v1.7.1，我希望可以升级到最新版本，那么我们需要做的是下载 git 源码包并编译。 源码包可以到这里下载：https://www.kernel.org/pub/software/scm/git/，选择一个自己想要的版本即可。 下载并解压： wget https://www.kernel.org/pub/software/scm/git/git-2.7.0.tar.gz tar -zxvf git-2.7.0.tar.gz 接下来安装编译时需要的依赖： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidoc yum install gcc perl-ExtUtils-MakeMaker 进入到 git 源码的目录中，开始编译： cd git-2.7.0 make configure ./configure make all doc make install install-doc install-html git 升级完成，现在已经是 v2.7.0 的版本了。 安装 nvm 和 node.js git 安装完成后开始装 node.js，为了更好的控制和切换 node.js 的版本，我们首先安装 nvm。 根据在 github 上的说明，我们执行以下命令即可完成安装。 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.1/install.sh | bash 之后我们分别安装 node.js v4 和 v5 的最新版本。 nvm install 4 nvm install 5 node.js 安装完毕，之后统一使用 nvm 来做 node.js 的版本管理。 安装 nginx 直接使用 yum install nginx 并不能安装，需要手动添加 nginx 的源，这个在官网的文档中有说明，我们在这里选择 CentOS 6 下的稳定版： 创建文件 /etc/yum.repos.d/nginx.repo 并填入以下内容： [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/6/$basearch/ gpgcheck=0 enabled=1 然后使用 yum install nginx 安装即可。完成后查看版本，安装的是 v1.8.0。直接输入 nginx 来开启 nginx 服务，监听 80 端口请求。 配置防火墙 在启动 nginx 后，发现在本机的浏览器中输入虚拟机 ip 并不能访问，于是想到防火墙的问题。我们先查看防火墙的信息： service iptables status 我们发现只有 22 端口是被打开的： Table: filter Chain INPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 2 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 4 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22 5 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain FORWARD (policy ACCEPT) num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited Chain OUTPUT (policy ACCEPT) num target prot opt source destination 于是我们修改文件 /etc/sysconfig/iptables，添加上 80 和 443 端口。 # Firewall configuration written by system-config-firewall # Manual customization of this file is not recommended. *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 443 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited COMMIT 然后重启防火墙服务即可： service iptables restart 好了，到这里，基本的环境配置就完成了。 转自https://leozdgao.me/centos-v6-7-config/ ","link":"https://blog.coolcode.dev/post/20160116-26-CentOS v6.7 新装配置/"},{"title":"Java 8 简明教程","content":"“Java并没有没落，人们很快就会发现这一点” 欢迎阅读我编写的Java 8介绍。本教程将带领你一步一步地认识这门语言的新特性。通过简单明了的代码示例，你将会学习到如何使用默认接口方法，Lambda表达式，方法引用和重复注解。看完这篇教程后，你还将对最新推出的API有一定的了解，例如：流控制，函数式接口，map扩展和新的时间日期API等等。 允许在接口中有默认方法实现 Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。下面是我们的第一个例子： interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } 在接口Formula中，除了抽象方法caculate以外，还定义了一个默认方法sqrt。Formula的实现类只需要实现抽象方法caculate就可以了。默认方法sqrt可以直接使用。 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 formula对象以匿名对象的形式实现了Formula接口。代码很啰嗦：用了6行代码才实现了一个简单的计算功能：a*100开平方根。我们在下一节会看到，Java 8 还有一种更加优美的方法，能够实现包含单个函数的对象。 Lambda表达式 让我们从最简单的例子开始，来学习如何对一个string列表进行排序。我们首先使用Java 8之前的方法来实现： List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 静态工具方法Collections.sort接受一个list，和一个Comparator接口作为输入参数，Comparator的实现类可以对输入的list中的元素进行比较。通常情况下，你可以直接用创建匿名Comparator对象，并把它作为参数传递给sort方法。 除了创建匿名对象以外，Java 8 还提供了一种更简洁的方式，Lambda表达式。 Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); }); 你可以看到，这段代码就比之前的更加简短和易读。但是，它还可以更加简短： Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 只要一行代码，包含了方法体。你甚至可以连大括号对{}和return关键字都省略不要。不过这还不是最短的写法： Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器能够自动识别参数的类型，所以你就可以省略掉类型不写。让我们再深入地研究一下lambda表达式的威力吧。 函数式接口 Lambda表达式如何匹配Java的类型系统？每一个lambda都能够通过一个特定的接口，与一个给定的类型进行匹配。一个所谓的函数式接口必须要有且仅有一个抽象方法声明。每个与之对应的lambda表达式必须要与抽象方法的声明相匹配。由于默认方法不是抽象的，因此你可以在你的函数式接口里任意添加默认方法。 任意只包含一个抽象方法的接口，我们都可以用来做成lambda表达式。为了让你定义的接口满足要求，你应当在接口前加上@FunctionalInterface 标注。编译器会注意到这个标注，如果你的接口中定义了第二个抽象方法的话，编译器会抛出异常。 举例： @FunctionalInterface interface Converter&lt;F, T&gt; { T convert(F from); } Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); // 123 注意，如果你不写@FunctionalInterface 标注，程序也是正确的。 方法和构造函数引用 上面的代码实例可以通过静态方法引用，使之更加简洁： Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted); // 123 Java 8 允许你通过::关键字获取方法或者构造函数的的引用。上面的例子就演示了如何引用一个静态方法。而且，我们还可以对一个对象的方法进行引用： class Something { String startsWith(String s) { return String.valueOf(s.charAt(0)); } } Something something = new Something(); Converter&lt;String, String&gt; converter = something::startsWith; String converted = converter.convert(&quot;Java&quot;); System.out.println(converted); // &quot;J&quot; 让我们看看如何使用::关键字引用构造函数。首先我们定义一个示例bean，包含不同的构造方法： class Person { String firstName; String lastName; Person() {} Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 接下来，我们定义一个person工厂接口，用来创建新的person对象： interface PersonFactory&lt;P extends Person&gt; { P create(String firstName, String lastName); } 然后我们通过构造函数引用来把所有东西拼到一起，而不是像以前一样，通过手动实现一个工厂来这么做。 PersonFactory&lt;Person&gt; personFactory = Person::new; Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;); 我们通过Person::new来创建一个Person类构造函数的引用。Java编译器会自动地选择合适的构造函数来匹配PersonFactory.create函数的签名，并选择正确的构造函数形式。 Lambda的范围 对于lambdab表达式外部的变量，其访问权限的粒度与匿名对象的方式非常类似。你能够访问局部对应的外部区域的局部final变量，以及成员变量和静态变量。 访问局部变量 我们可以访问lambda表达式外部的final局部变量： final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 但是与匿名对象不同的是，变量num并不需要一定是final。下面的代码依然是合法的： int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 然而，num在编译的时候被隐式地当做final变量来处理。下面的代码就不合法： int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); num = 3; 在lambda表达式内部企图改变num的值也是不允许的。 访问成员变量和静态变量 与局部变量不同，我们在lambda表达式的内部能获取到对成员变量或静态变量的读写权。这种访问行为在匿名对象里是非常典型的。 class Lambda4 { static int outerStaticNum; int outerNum; void testScopes() { Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); }; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; { outerStaticNum = 72; return String.valueOf(from); }; } } 访问默认接口方法 还记得第一节里面formula的那个例子么？ 接口Formula定义了一个默认的方法sqrt，该方法能够访问formula所有的对象实例，包括匿名对象。这个对lambda表达式来讲则无效。 默认方法无法在lambda表达式内部被访问。因此下面的代码是无法通过编译的： Formula formula = (a) -&gt; sqrt( a * 100); 内置函数式接口 JDK 1.8 API中包含了很多内置的函数式接口。有些是在以前版本的Java中大家耳熟能详的，例如Comparator接口，或者Runnable接口。对这些现成的接口进行实现，可以通过@FunctionalInterface 标注来启用Lambda功能支持。 此外，Java 8 API 还提供了很多新的函数式接口，来降低程序员的工作负担。有些新的接口已经在Google Guava库中很有名了。如果你对这些库很熟的话，你甚至闭上眼睛都能够想到，这些接口在类库的实现过程中起了多么大的作用。 Predicates Predicate是一个布尔类型的函数，该函数只有一个输入参数。Predicate接口包含了多种默认方法，用于处理复杂的逻辑动词（and, or，negate） Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; predicate.test(&quot;foo&quot;); // true predicate.negate().test(&quot;foo&quot;); // false Predicate&lt;Boolean&gt; nonNull = Objects::nonNull; Predicate&lt;Boolean&gt; isNull = Objects::isNull; Predicate&lt;String&gt; isEmpty = String::isEmpty; Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Functions Function接口接收一个参数，并返回单一的结果。默认方法可以将多个函数串在一起（compse, andThen） Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); backToString.apply(&quot;123&quot;); // &quot;123&quot; Suppliers Supplier接口产生一个给定类型的结果。与Function不同的是，Supplier没有输入参数。 Supplier&lt;Person&gt; personSupplier = Person::new; personSupplier.get(); // new Person Consumers Consumer代表了在一个输入参数上需要进行的操作。 Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName); greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;)); Comparators Comparator接口在早期的Java版本中非常著名。Java 8 为这个接口添加了不同的默认方法。 Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName); Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;); Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;); comparator.compare(p1, p2); // &gt; 0 comparator.reversed().compare(p1, p2); // &lt; 0 Optionals Optional不是一个函数式接口，而是一个精巧的工具接口，用来防止NullPointerEception产生。这个概念在下一节会显得很重要，所以我们在这里快速地浏览一下Optional的工作原理。 Optional是一个简单的值容器，这个值可以是null，也可以是non-null。考虑到一个方法可能会返回一个non-null的值，也可能返回一个空值。为了不直接返回null，我们在Java 8中就返回一个Optional. Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;); optional.isPresent(); // true optional.get(); // &quot;bam&quot; optional.orElse(&quot;fallback&quot;); // &quot;bam&quot; optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // &quot;b&quot; Streams java.util.Stream表示了某一种元素的序列，在这些元素上可以进行各种操作。Stream操作可以是中间操作，也可以是完结操作。完结操作会返回一个某种类型的值，而中间操作会返回流对象本身，并且你可以通过多次调用同一个流操作方法来将操作结果串起来（就像StringBuffer的append方法一样————译者注）。Stream是在一个源的基础上创建出来的，例如java.util.Collection中的list或者set（map不能作为Stream的源）。Stream操作往往可以通过顺序或者并行两种方式来执行。 我们先了解一下序列流。首先，我们通过string类型的list的形式创建示例数据： List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;(); stringCollection.add(&quot;ddd2&quot;); stringCollection.add(&quot;aaa2&quot;); stringCollection.add(&quot;bbb1&quot;); stringCollection.add(&quot;aaa1&quot;); stringCollection.add(&quot;bbb3&quot;); stringCollection.add(&quot;ccc&quot;); stringCollection.add(&quot;bbb2&quot;); stringCollection.add(&quot;ddd1&quot;); Java 8中的Collections类的功能已经有所增强，你可以之直接通过调用Collections.stream()或者Collection.parallelStream()方法来创建一个流对象。下面的章节会解释这个最常用的操作。 Filter Filter接受一个predicate接口类型的变量，并将所有流对象中的元素进行过滤。该操作是一个中间操作，因此它允许我们在返回结果的基础上再进行其他的流操作（forEach）。ForEach接受一个function接口类型的变量，用来执行对每一个元素的操作。ForEach是一个中止操作。它不返回流，所以我们不能再调用其他的流操作。 stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println); // &quot;aaa2&quot;, &quot;aaa1&quot; Sorted Sorted是一个中间操作，能够返回一个排过序的流对象的视图。流对象中的元素会默认按照自然顺序进行排序，除非你自己指定一个Comparator接口来改变排序规则。 stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println); // &quot;aaa1&quot;, &quot;aaa2&quot; 一定要记住，sorted只是创建一个流对象排序的视图，而不会改变原来集合中元素的顺序。原来string集合中的元素顺序是没有改变的。 System.out.println(stringCollection); // ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map map是一个对于流对象的中间操作，通过给定的方法，它能够把流对象中的每一个元素对应到另外一个对象上。下面的例子就演示了如何把每个string都转换成大写的string. 不但如此，你还可以把每一种对象映射成为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给map的泛型方法来决定。 stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println); // &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot; Match 匹配操作有多种不同的类型，都是用来判断某一种规则是否与流对象相互吻合的。所有的匹配操作都是终结操作，只返回一个boolean类型的结果。 boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(allStartsWithA); // false boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;)); System.out.println(noneStartsWithZ); // true Count Count是一个终结操作，它的作用是返回一个数值，用来标识当前流对象中包含的元素数量。 long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count(); System.out.println(startsWithB); // 3 Reduce 该操作是一个终结操作，它能够通过某一个方法，对元素进行削减操作。该操作的结果会放在一个Optional变量里返回。 Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2); reduced.ifPresent(System.out::println); // &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot; Parallel Streams 像上面所说的，流操作可以是顺序的，也可以是并行的。顺序操作通过单线程执行，而并行操作则通过多线程执行。 下面的例子就演示了如何使用并行流进行操作来提高运行效率，代码非常简单。 首先我们创建一个大的list，里面的元素都是唯一的： int max = 1000000; List&lt;String&gt; values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) { UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); } 现在，我们测量一下对这个集合进行排序所使用的时间。 顺序排序 long t0 = System.nanoTime(); long count = values.stream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis)); // sequential sort took: 899 ms 并行排序 long t0 = System.nanoTime(); long count = values.parallelStream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis)); // parallel sort took: 472 ms 如你所见，所有的代码段几乎都相同，唯一的不同就是把stream()改成了parallelStream(), 结果并行排序快了50%。 Map 正如前面已经提到的那样，map是不支持流操作的。而更新后的map现在则支持多种实用的新方法，来完成常规的任务。 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { map.putIfAbsent(i, &quot;val&quot; + i); } map.forEach((id, val) -&gt; System.out.println(val)); 上面的代码风格是完全自解释的：putIfAbsent避免我们将null写入；forEach接受一个消费者对象，从而将操作实施到每一个map中的值上。 下面的这个例子展示了如何使用函数来计算map的编码 map.computeIfPresent(3, (num, val) -&gt; val + num); map.get(3); // val33 map.computeIfPresent(9, (num, val) -&gt; null); map.containsKey(9); // false map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num); map.containsKey(23); // true map.computeIfAbsent(3, num -&gt; &quot;bam&quot;); map.get(3); // val33 接下来，我们将学习，当给定一个key值时，如何把一个实例从对应的key中移除： map.remove(3, &quot;val3&quot;); map.get(3); // val33 map.remove(3, &quot;val33&quot;); map.get(3); // null 另一个有用的方法： map.getOrDefault(42, &quot;not found&quot;); // not found 将map中的实例合并也是非常容易的： map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9 map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9concat 合并操作先看map中是否没有特定的key/value存在，如果是，则把key/value存入map，否则merging函数就会被调用，对现有的数值进行修改。 时间日期API Java 8 包含了全新的时间日期API，这些功能都放在了java.time包下。新的时间日期API是基于Joda-Time库开发的，但是也不尽相同。下面的例子就涵盖了大多数新的API的重要部分。 Clock Clock提供了对当前时间和日期的访问功能。Clock是对当前时区敏感的，并可用于替代System.currentTimeMillis()方法来获取当前的毫秒时间。当前时间线上的时刻可以用Instance类来表示。Instance也能够用于创建原先的java.util.Date对象。 Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区类可以用一个ZoneId来表示。时区类的对象可以通过静态工厂方法方便地获取。时区类还定义了一个偏移量，用来在当前时刻或某时间与目标时区时间之间进行转换。 System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;); ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间类表示一个没有指定时区的时间，例如，10 p.m.或者17：30:15，下面的例子会用上面的例子定义的时区创建两个本地时间对象。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。 LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime是由多个工厂方法组成，其目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作。 LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter); System.out.println(leetTime); // 13:37 LocalDate 本地时间表示了一个独一无二的时间，例如：2014-03-11。这个时间是不可变的，与LocalTime是同源的。下面的例子演示了如何通过加减日，月，年等指标来计算新的日期。记住，每一次操作都会返回一个新的时间对象。 LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(dayOfWeek); // FRIDAY 解析字符串并形成LocalDate对象，这个操作和解析LocalTime一样简单。 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter); System.out.println(xmas); // 2014-12-24 LocalDateTime LocalDateTime表示的是日期-时间。它将刚才介绍的日期对象和时间对象结合起来，形成了一个对象实例。LocalDateTime是不可变的，与LocalTime和LocalDate的工作原理相同。我们可以通过调用方法来获取日期时间对象中特定的数据域。 LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 如果再加上的时区信息，LocalDateTime能够被转换成Instance实例。Instance能够被转换成以前的java.util.Date对象。 Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化日期-时间对象就和格式化日期对象或者时间对象一样。除了使用预定义的格式以外，我们还可以创建自定义的格式化对象，然后匹配我们自定义的格式。 DateTimeFormatter formatter = DateTimeFormatter .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;); LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 不同于java.text.NumberFormat，新的DateTimeFormatter类是不可变的，也是线程安全的。 更多的细节，请看这里 Annotations Java 8中的注解是可重复的。让我们直接深入看看例子，弄明白它是什么意思。 首先，我们定义一个包装注解，它包括了一个实际注解的数组 @interface Hints { Hint[] value(); } @Repeatable(Hints.class) @interface Hint { String value(); } 只要在前面加上注解名：@Repeatable，Java 8 允许我们对同一类型使用多重注解， 变体1：使用注解容器（老方法） @Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)}) class Person {} 变体2：使用可重复注解（新方法） @Hint(&quot;hint1&quot;) @Hint(&quot;hint2&quot;) class Person {} 使用变体2，Java编译器能够在内部自动对@Hint进行设置。这对于通过反射来读取注解信息来说，是非常重要的。 Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2 Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2 尽管我们绝对不会在Person类上声明@Hints注解，但是它的信息仍然可以通过getAnnotation(Hints.class)来读取。并且，getAnnotationsByType方法会更方便，因为它赋予了所有@Hints注解标注的方法直接的访问权限。 @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {} 先到这里 我的Java 8编程指南就到此告一段落。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对JDK 8进行探究了，例如：Arrays.parallelSort, StampedLock和CompletableFuture等等 ———— 我这里只是举几个例子而已。 我希望这个博文能够对您有所帮助，也希望您阅读愉快。完整的教程源代码放在了GitHub上。您可以尽情地fork，并请通过Twitter告诉我您的反馈。 原文链接： winterbe 翻译： ImportNew.com - 黄小非 译文链接： http://www.importnew.com/10360.html ","link":"https://blog.coolcode.dev/post/20151229-1-Java 8 简明教程/"},{"title":"Oracle 19c 安装scott用户以及数据库","content":"登录sys超级用户，查看PDB容器名 show pdbs SQL&gt; show pdbs CON_ID CON_NAME OPEN MODE RESTRICTED ---------- ------------------------------ ---------- ---------- 3 ORCLPDB READ WRITE NO 比如显示ORCLPDB 使用sys用户登录到PDB conn sys/密码@localhost:1521/ORCLPDB as sysdba; 创建scott用户 GRANT CONNECT,RESOURCE,UNLIMITED TABLESPACE TO SCOTT IDENTIFIED BY TIGER; ALTER USER SCOTT DEFAULT TABLESPACE USERS; ALTER USER SCOTT TEMPORARY TABLESPACE TEMP; 解锁scott用户： alter user scott account unlock; 登录scott用户 conn scott /tiger@localhost:1521/ORCLPDB; 导入scott用户的表，找到WINDOWS.X64_193000_db_home\\rdbms\\admin\\scott.sql文件里面的建表和数据SQL语句 验证数据 select * from emp; PL/SQL Developer登录scott用户 用户名：scott 密码：tiger 数据库：localhost:1521/ORCLPDB 连接为：Normal ","link":"https://blog.coolcode.dev/post/Oracle 19c 安装scott用户以及数据库-oracle19c-an-zhuang-scott-yong-hu-yi-ji-shu-ju-ku/"},{"title":"配置HTTPS及自动续期","content":" certbot-auto在2020年3月份停止维护，目前域名更新暂未受影响，但新增已经无法使用，官方建议使用snap进行certbot的安装和更新。 一、基本环境 1、安装依赖 sudo yum install openssl sudo yum install epel-release 2、生成2048位 DH parameters： sudo openssl dhparam -out /etc/letsencrypt/live/dhparams.pem 2048 3、安装snap sudo yum install snapd 4、启用管理主 snap 通信套接字的 systemd 单元： sudo ln -s /var/lib/snapd/snap /snap sudo systemctl start snapd.service sudo systemctl enable snapd.service 5、更新snap到最新版 sudo snap install core; sudo snap refresh core 6、删除 certbot-auto 和任何 Certbot OS 包 sudo apt-get remove certbot（Ubuntu） sudo dnf remove certbot（CentOS8） sudo yum remove certbot.（CentOS7） 清理certbot-auto 参考链接：https://certbot.eff.org/docs/uninstall.html 7、安装certbot sudo snap install --classic certbot 确保/var/lib属主和属组均为root，不然会安装失败 8、建立连接，确保certbot失效 sudo ln -s /snap/bin/certbot /usr/bin/certbot 9、执行命令安装证书 sudo certbot --nginx（自动） Certbot默认nginx配置文件在 /etc/nginx/nginx.conf 或 /usr/local/etc/nginx/nginx.conf，若你的nginx配置文件不在此处（以/usr/local/nginx/conf/nginx.conf为例），需在命令加上 **--nginx-server-root /usr/local/nginx/conf，**主配置文件所在目录，不是虚拟主机配置文件目录。 sudo certbot certonly --nginx（手动） 配置文件同上操作，执行后会出现选择域名列表，多个域名空格隔开，不在需要老版的各种参数，需要手动调整配置文件。 10、自动更新 Certbot 软件包带有一个 cron 作业或 systemd 计时器，它们会在证书到期之前自动更新证书。除非更改配置，否则无需再次运行 Certbot。可以通过运行以下命令来测试证书的自动续订： sudo certbot renew --dry-run 二、DNS指向及域名的http服务 三、域名验证 1、nginx配置文件 location /.well-known/acme-challenge/ { allow all; } 2、如果使用apache，移除apache的干扰 mv /etc/httpd/conf.d/ssl.conf /etc/httpd/conf.d/ssl.conf.org service httpd restart 3、修改配置nginx文件 if ($scheme = http) { #return 301 https://$server_name$request_uri; (强制跳转) } location ~ /.well-known { allow all; } listen 443 ssl; ssl_certificate /etc/letsencrypt/live/www.yri.cc/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.yri.cc/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA'; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:20m; ssl_session_timeout 20m; ssl_dhparam /etc/letsencrypt/live/dhparams.pem; 5、nginx重新加载 6、打开防火墙端口 firewall-cmd --zone=public --add-port=443/tcp firewall-cmd --zone=public --add-port=443/tcp --permanent # 查看效果 firewall-cmd --list-all 7、浏览器测试 ","link":"https://blog.coolcode.dev/post/配置HTTPS及自动续期-pei-zhi-https-ji-zi-dong-xu-qi/"},{"title":"计算机基础课程","content":"计算机基础课程 计算机组成原理 视频： 计算机组成原理（哈工大刘宏伟）135讲（全）高清_哔哩哔哩_bilibili 计算机操作系统 视频：[完结] 2020 南京大学 “操作系统：设计与实现” (蒋炎岩)_哔哩哔哩_bilibili 书籍： 《深入理解计算机系统》 《现代操作系统》 数据库 视频：中国人民大学公开课：数据库系统概论（基础篇）-网易公开课 (163.com) 书籍： 《SQL必知必会（第五版）》 《MySQL技术内幕——InnoDB存储引擎（第二版）》 计算机网络 视频：计算机网络微课堂（有字幕无背景音乐版）_哔哩哔哩_bilibili 书籍： 《计算机网络——自顶向下方法》 《计算机是怎么连接起来的》 数据结构 视频：【浙江大学】数据结构_哔哩哔哩_bilibili 书籍： 《数据结构与算法分析——C语言描述》 ","link":"https://blog.coolcode.dev/post/计算机基础课程-ji-suan-ji-ji-chu-ke-cheng/"},{"title":"Mac系统爬取所有M3U8视频下载方法-FFmpeg","content":"前言 由于有的网站不允许下载视频，到了有效期就不能看了，但是我想以后反复看，怎么办呢？ 前提准备 操作系统：Mac 浏览器：谷歌浏览器 抓取m3u8工具：猫爪 视频处理工具：ffmpeg 需要安装工具：homebrew 步骤 1、安装ffmpeg 安装命令ffmpeg： brew install ffmpeg 用brew命令，需要安装homebrew请参考下面的文章： 《【Mac + Python】苹果系统之安装Python3.6.x环境》 2、查看ffmpeg安装信息 brew info ffmpeg 有红叉的代表是没有这个库，有绿色的对勾的表示此库已经安装上了。 3、抓取M3U8地址 首先在谷歌浏览器中安装猫爪插件，具体安装步骤自行百度 首先打开视频后，查看 https://1258712167.vod2.myqcloud.com/fb8e6c92vodtranscq1258712167/d2d290e45285890788294575847/drm/voddrm.token.dWluPTE0NDExNTIxMjI1NDUyMzk0OTt2b2RfdHlwZT0wO2NpZD0xNzc4Njc7dGVybV9pZD0xMDAyMDkyMTY7ZXh0PWM5MGNiZDExNDNkOWZjNTgzN2U5MjdlZDg4MjlhN2VlN2Q0YjRlNDZiZTc0OTdiMGU3MmI0MmRjZDZlYmM5NzdiMTlmMDgyYjM1NGJiYmIzNDY0MGFhYjFkNDZiYTEwN2YwYWRkMWVmNmQ4NTkwZDNiOGE3NGZlNjczYzYzODUyZGUzOWVjODAwOGUxYTYwZQ==.v.f30741.m3u8?exper=0&amp;sign=32c5411352762a9ad7716df57da546d3&amp;t=60672ebf&amp;us=8985634549565757842 4、视频转换 输入命令： ffmpeg -i https://1258712167.vod2.myqcloud.com/fb8e6c92vodtranscq1258712167/d2d290e45285890788294575847/drm/voddrm.token.dWluPTE0NDExNTIxMjI1NDUyMzk0OTt2b2RfdHlwZT0wO2NpZD0xNzc4Njc7dGVybV9pZD0xMDAyMDkyMTY7ZXh0PWM5MGNiZDExNDNkOWZjNTgzN2U5MjdlZDg4MjlhN2VlN2Q0YjRlNDZiZTc0OTdiMGU3MmI0MmRjZDZlYmM5NzdiMTlmMDgyYjM1NGJiYmIzNDY0MGFhYjFkNDZiYTEwN2YwYWRkMWVmNmQ4NTkwZDNiOGE3NGZlNjczYzYzODUyZGUzOWVjODAwOGUxYTYwZQ==.v.f30741.m3u8?exper=0&amp;sign=32c5411352762a9ad7716df57da546d3&amp;t=60672ebf&amp;us=8985634549565757842 -c copy 【下载本地路径】/video.mp4 下载合成视频转换： 最后下载成功啦~~~??ヽ(°▽°)ノ? 还有一种情况，另一台Mac电脑上一直报错，安装不了，查询信息也出不来。 参考如下方法即可解决： # 1）执行 brew tap homebrew-ffmpeg/ffmpeg # 2）执行 brew install homebrew-ffmpeg/ffmpeg/ffmpeg # 3）执行如下命令，看此仓库支持哪些options。 brew options homebrew-ffmpeg/ffmpeg/ffmpeg # 4）根据第3）步得到的options，替换下面命令中的option,然后执行 brew install homebrew-ffmpeg/ffmpeg/ffmpeg --with-&lt;option1&gt; --with-&lt;option2&gt; ... 运行完上述步骤后，即可安装ffmpeg成功。 安装过程中，可能会出现下面的问题： brew安装报错 “cp: utimes: /usr/local/Cellar/jemalloc/.: Operation not permitted cp: chmod: /usr/local/C” cp: utimes: /usr/local/Cellar/jemalloc/.: Operation not permitted cp: chmod: /usr/local/Cellar/jemalloc/.: Operation not permitted 解决办法： sudo chown -R $(whoami) /usr/local/Cellar 继续安装就可以成功了。 输入命令： ffmpeg 附录 ①感谢阳光的大男孩儿的：《Mac 配置FFmpeg环境》***** ②感谢花逢春Tim的：《转载：腾讯课堂直播视频下载》***** ③感谢jameswhale的：《Mac OS上使用ffmpeg的“血泪”总结》***** ④感谢芥焉丶的：《brew安装报错 “cp: utimes: /usr/local/Cellar/jemalloc/.: Operation not permitted cp: chmod: /usr/local/C”》*** 其他参考文章 ①《[原创工具] M3U8多线程下载器 V1.0.3 ，支持Windows、MacOS》 ②《腾讯课堂在线视频下载》 ③《怎么下载腾讯课堂M3U8格式的视频》 ④kervias的文章：《Python爬虫下载腾讯课堂回放视频》 ⑤kervias的github：https://github.com/kerviasx ","link":"https://blog.coolcode.dev/post/Mac系统爬取所有M3U8视频下载方法-FFmpeg-mac-xi-tong-pa-qu-suo-you-m3u8-shi-pin-xia-zai-fang-fa--ffmpeg/"},{"title":"OpenJDK Providers and Comparison","content":" AdoptOpenJDK - https://adoptopenjdk.net Amazon – Corretto - https://aws.amazon.com/corretto Azul Zulu - https://www.azul.com/downloads/zulu/ BellSoft Liberica - https://bell-sw.com/java.html IBM - https://www.ibm.com/developerworks/java/jdk jClarity - https://www.jclarity.com/adoptopenjdk-support/ OpenJDK Upstream - https://adoptopenjdk.net/upstream.html Oracle JDK - https://www.oracle.com/technetwork/java/javase/downloads Oracle OpenJDK - http://jdk.java.net ojdkbuild - https://github.com/ojdkbuild/ojdkbuild RedHat - https://developers.redhat.com/products/openjdk/overview SapMachine - https://sap.github.io/SapMachine ---------------------------------------------------------------------------------------- | Provider | Free Builds | Free Binary | Extended | Commercial | Permissive | | | from Source | Distributions | Updates | Support | License | |--------------------------------------------------------------------------------------| | AdoptOpenJDK | Yes | Yes | Yes | No | Yes | | Amazon – Corretto | Yes | Yes | Yes | No | Yes | | Azul Zulu | No | Yes | Yes | Yes | Yes | | BellSoft Liberica | No | Yes | Yes | Yes | Yes | | IBM | No | No | Yes | Yes | Yes | | jClarity | No | No | Yes | Yes | Yes | | OpenJDK | Yes | Yes | Yes | No | Yes | | Oracle JDK | No | Yes | No** | Yes | No | | Oracle OpenJDK | Yes | Yes | No | No | Yes | | ojdkbuild | Yes | Yes | No | No | Yes | | RedHat | Yes | Yes | Yes | Yes | Yes | | SapMachine | Yes | Yes | Yes | Yes | Yes | ---------------------------------------------------------------------------------------- Free Builds from Source - the distribution source code is publicly available and one can assemble its own build Free Binary Distributions - the distribution binaries are publicly available for download and usage Extended Updates - aka LTS (long-term support) - Public Updates beyond the 6-month release lifecycle Commercial Support - some providers offer extended updates and customer support to paying customers, e.g. Oracle JDK (support details) Permissive License - the distribution license is non-protective, e.g. Apache 2.0 ","link":"https://blog.coolcode.dev/post/OpenJDK Providers and Comparison-openjdkprovidersandcomparison/"},{"title":"CentOS 7 yum 安装 Docker","content":"更新系统 sudo yum check-update 删除旧版docker sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装Docker依赖 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加Docker仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装Docker sudo yum install docker-ce docker-ce-cli containerd.io 管理Docker服务 启动Docker sudo systemctl start docker 添加Docker服务 sudo systemctl enable docker 查看Docker服务状态 sudo systemctl status docker ","link":"https://blog.coolcode.dev/post/CentOS 7 yum 安装 Docker-centos7yum安装docker/"},{"title":"Oracle快速静默安装","content":"参考地址：https://blog.51cto.com/mflag/2420185 操作系统环境：最小化安装 centos7 一、创建目录、更新补丁、安装依赖包与创建用户 mkdir -p /data/u01/software yum -y groupinstall 'Development Tools' yum -y install epel-release lrzsz vim unzip net-tools lsof groupadd oinstall groupadd dba useradd -g oinstall -G dba oracle echo &quot;oracleadmin&quot; | passwd --stdin oracle mkdir -p /data/u01/app/oracle/product/11.2.0/dbhome_1 mkdir /data/u01/app/oracle/{oradata,inventory,fast_recovery_area} chown -R oracle:oinstall /data/u01/app/oracle chmod -R 775 /data/u01/app/oracle yum -y install gcc gcc-c++ make binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static glibc glibc-common glibc-devel ksh libaio libaio-devel libgcc libstdc++ libstdc++-devel numactl-devel sysstat unixODBC unixODBC-devel kernelheaders pdksh pcre-devel readline* rlwrap yum -y update cd /data/u01/software ls 二、新会话：上传安装包 cd /data/u01/software ls 上传Oracle安装包linux.x64_11gR2_database* 三、新会话修改配置文件、安装sqlplus echo &quot;#&quot;(date) &quot;quick install oracle11GR2 add vim /etc/sysctl.conf&quot;&gt;&gt; /etc/sysctl.conf echo &quot;fs.aio-max-nr = 1048576&quot; &gt;&gt; /etc/sysctl.conf echo &quot;fs.file-max = 6815744&quot; &gt;&gt; /etc/sysctl.conf echo &quot;kernel.shmall = 2097152&quot; &gt;&gt; /etc/sysctl.conf echo &quot;kernel.shmmax = 1073741824&quot; &gt;&gt; /etc/sysctl.conf echo &quot;kernel.shmmni = 4096&quot; &gt;&gt; /etc/sysctl.conf echo &quot;kernel.sem = 250 32000 100 128&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.ipv4.ip_local_port_range = 9000 65500&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.core.rmem_default = 262144&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.core.rmem_max = 4194304&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.core.wmem_default = 262144&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.core.wmem_max = 1048576&quot; &gt;&gt; /etc/sysctl.conf sysctl -p echo &quot;#&quot;(date) &quot;quick install oracle11GR2 add vim /etc/security/limits.conf&quot;&gt;&gt;/etc/security/limits.conf echo &quot;oracle soft nproc 2047&quot; &gt;&gt;/etc/security/limits.conf echo &quot;oracle hard nproc 16384&quot; &gt;&gt;/etc/security/limits.conf echo &quot;oracle soft nofile 1024&quot; &gt;&gt;/etc/security/limits.conf echo &quot;oracle hard nofile 65536&quot; &gt;&gt;/etc/security/limits.conf echo &quot;oracle soft stack 10240&quot; &gt;&gt;/etc/security/limits.conf echo &quot;#&quot;$(date) &quot;quick install oracle11GR2 add vim /etc/pam.d/login&quot;&gt;&gt;/etc/pam.d/login echo &quot;session required /lib64/security/pam_limits.so&quot;&gt;&gt;/etc/pam.d/login echo &quot;session required pam_limits.so&quot;&gt;&gt;/etc/pam.d/login echo &quot;#&quot;$(date) &quot;quick install oracle11GR2 add vim /etc/profile&quot;&gt;&gt;/etc/profile echo 'if [ $USER = &quot;oracle&quot; ]; then'&gt;&gt;/etc/profile echo 'if [ $SHELL = &quot;/bin/ksh&quot; ]; then'&gt;&gt;/etc/profile echo &quot;ulimit -p 16384&quot;&gt;&gt;/etc/profile echo &quot;ulimit -n 65536&quot;&gt;&gt;/etc/profile echo &quot;else&quot;&gt;&gt;/etc/profile echo &quot;ulimit -u 16384 -n 65536&quot;&gt;&gt;/etc/profile echo &quot;fi&quot;&gt;&gt;/etc/profile echo &quot;fi&quot;&gt;&gt;/etc/profile cd /data/u01/software 前面已经安装，此步忽略 #tar -xvf rlwrap-0.42.tar.gz #cd rlwrap-0.42 #./configure #make #make install 需要等上传完成； unzip linux.x64_11gR2_database_1of2.zip unzip linux.x64_11gR2_database_2of2.zip su - oracle echo &quot;#&quot;(date)&quot;quickinstalloracle11GR2addvim.bashprofile&quot;&gt;&gt;.bashprofileecho&quot;exportORACLEBASE=/data/u01/app/oracle&quot;&gt;&gt;.bashprofileecho&quot;exportORACLEHOME=/data/u01/app/oracle/product/11.2.0/dbhome1&quot;&gt;&gt;.bashprofileecho&quot;exportORACLESID=orcl&quot;&gt;&gt;.bashprofileecho′exportORACLEUNQNAME=(date) &quot;quick install oracle11GR2 add vim .bash_profile&quot;&gt;&gt;.bash_profile echo &quot;export ORACLE_BASE=/data/u01/app/oracle&quot;&gt;&gt;.bash_profile echo &quot;export ORACLE_HOME=/data/u01/app/oracle/product/11.2.0/dbhome_1&quot;&gt;&gt;.bash_profile echo &quot;export ORACLE_SID=orcl&quot;&gt;&gt;.bash_profile echo &#x27;export ORACLE_UNQNAME=(date)&quot;quickinstalloracle11GR2addvim.bashp​rofile&quot;&gt;&gt;.bashp​rofileecho&quot;exportORACLEB​ASE=/data/u01/app/oracle&quot;&gt;&gt;.bashp​rofileecho&quot;exportORACLEH​OME=/data/u01/app/oracle/product/11.2.0/dbhome1​&quot;&gt;&gt;.bashp​rofileecho&quot;exportORACLES​ID=orcl&quot;&gt;&gt;.bashp​rofileecho′exportORACLEU​NQNAME=ORACLE_SID'&gt;&gt;.bash_profile echo 'export PATH=ORACLEHOME/bin:ORACLE_HOME/bin:ORACLEH​OME/bin:PATH'&gt;&gt;.bash_profile echo &quot;export NLS_LANG=american_america.AL32UTF8&quot;&gt;&gt;.bash_profile echo &quot;alias sqlplus='rlwrap sqlplus'&quot;&gt;&gt;.bash_profile echo &quot;alias rman='rlwrap rman'&quot;&gt;&gt;.bash_profile source .bash_profile ls 以下第四，五步可以使用本地已经配置好的response.tar.gz包上传到 /home/oracle/ 目录 然后执行： cd /data/u01/software/database/ ./runInstaller -silent -responseFile /home/oracle/response/db_install.rsp -ignorePrereq 等待执行成功 继续执行安装实例： dbca -silent -responseFile /home/oracle/response/dbca.rsp 等待执行成功 四、修改静默响应文件并执行安装 拷贝备份一份响应文件： cp -R /data/u01/software/database/response/ . cd response/ vim db_install.rsp 修改内容： oracle.install.option=INSTALL_DB_SWONLY ORACLE_HOSTNAME=localhost.localdomain UNIX_GROUP_NAME=oinstall INVENTORY_LOCATION=/data/u01/app/oracle/inventory SELECTED_LANGUAGES=en,zh_CN ORACLE_HOME=/data/u01/app/oracle/product/11.2.0/dbhome_1 ORACLE_BASE=/data/u01/app/oracle oracle.install.db.InstallEdition=EE oracle.install.db.DBA_GROUP=dba oracle.install.db.OPER_GROUP=dba DECLINE_SECURITY_UPDATES=true 切换到解压的安装包目录执行安装： cd /data/u01/software/database/ ./runInstaller -silent -responseFile /home/oracle/response/db_install.rsp -ignorePrereq sqlplus / as sysdba linux CentOS7下快速静默安装Oracle11GR2数据库并创建实例 五、切换一个会话开始配置实例响应文件 配置响应文件： vim /home/oracle/response/dbca.rsp 修改内容（注意修改选项前面的#要删除）： GDBNAME = &quot;orcl&quot; SID = &quot;orcl&quot; SYSPASSWORD = &quot;输入密码&quot; SYSTEMPASSWORD = &quot;输入密码&quot; SYSMANPASSWORD = &quot;输入密码&quot; DBSNMPPASSWORD = &quot;输入密码&quot; DATAFILEDESTINATION =/data/u01/app/oracle/oradata RECOVERYAREADESTINATION=/data/u01/app/oracle/fast_recovery_area CHARACTERSET = &quot;AL32UTF8&quot; TOTALMEMORY = &quot;2048&quot; egrep -v &quot;(#|$)&quot; /home/oracle/response/dbca.rsp 安装创建（等第六步成功后执行）： cd ~ dbca -silent -responseFile /home/oracle/response/dbca.rsp linux CentOS7下快速静默安装Oracle11GR2数据库并创建实例 六、数据库操作 1、检查oracle数据库是否启动：ps -ef | grep ora 2、检查Oracle DB监听器是否正常： 输入：lsnrctl status 检查监听是否启动，如未启动 输入：lsnrctl start 启动监听器； lsnrctl stop 停止监听器命令 netstat -ntlp 查看1521端口是否启动 3、进入sqlplus界面： sqlplus /nolog; conn / as sysdba; 然后startup启动数据库实例和数据库 shutdown关闭数据库实例 ","link":"https://blog.coolcode.dev/post/Oracle快速静默安装-oracle快速静默安装/"},{"title":"How do I set the time zone of MySQL?","content":"原文地址：https://stackoverflow.com/questions/930900/how-do-i-set-the-time-zone-of-mysql On one server, when I run: mysql&gt; select now(); +---------------------+ | now() | +---------------------+ | 2009-05-30 16:54:29 | +---------------------+ 1 row in set (0.00 sec) On another server: mysql&gt; select now(); +---------------------+ | now() | +---------------------+ | 2009-05-30 20:01:43 | +---------------------+ 1 row in set (0.00 sec) I thought this might be useful: There are three places where the timezone might be set in MySQL: In the file &quot;my.cnf&quot; in the [mysqld] section default-time-zone='+00:00' @@global.time_zone variable To see what value they are set to: SELECT @@global.time_zone; To set a value for it use either one: SET GLOBAL time_zone = '+8:00'; SET GLOBAL time_zone = 'Europe/Helsinki'; SET @@global.time_zone = '+00:00'; (Using named timezones like 'Europe/Helsinki' means that you have to have a timezone table properly populated.) Keep in mind that +02:00 is an offset. Europe/Berlin is a timezone (that has two offsets) and CEST is a clock time that corresponds to a specific offset. @@session.time_zone variable SELECT @@session.time_zone; To set it use either one: SET time_zone = 'Europe/Helsinki'; SET time_zone = &quot;+00:00&quot;; SET @@session.time_zone = &quot;+00:00&quot;; Both might return SYSTEM which means that they use the timezone set in my.cnf. For timezone names to work, you must setup your timezone information tables need to be populated: http://dev.mysql.com/doc/refman/5.1/en/time-zone-support.html. I also mention how to populate those tables in this answer. To get the current timezone offset as TIME SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP); It will return 02:00:00 if your timezone is +2:00. To get the current UNIX timestamp: SELECT UNIX_TIMESTAMP(); SELECT UNIX_TIMESTAMP(NOW()); To get the timestamp column as a UNIX timestamp SELECT UNIX_TIMESTAMP(`timestamp`) FROM `table_name` To get a UTC datetime column as a UNIX timestamp SELECT UNIX_TIMESTAMP(CONVERT_TZ(`utc_datetime`, '+00:00', @@session.time_zone)) FROM `table_name` Note: Changing the timezone will not change the stored datetime or timestamp, but it will show a different datetime for existing timestamp columns as they are internally stored as UTC timestamps and externally displayed in the current MySQL timezone. I made a cheatsheet here: Should MySQL have its timezone set to UTC? For anyone still having this issue: value=&quot;jdbc:mysql://localhost:3306/dbname?serverTimezone=UTC&quot; Worked for me. Just append ?serverTimezone=UTC at the end. ","link":"https://blog.coolcode.dev/post/How do I set the time zone of MySQL-howdoisetthetimezoneofmysql/"},{"title":"MySQL的my.ini配置文件","content":"[mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=C:\\mysql8 # 设置mysql数据库的数据的存放目录 datadir=E:\\mysql-dc\\data # mysqlsock存储目录 socket=E:\\mysql-dc\\data\\mysql.sock # 允许最大连接数 max_connections=l0000 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors= 10 # 服务端使用的字符集默认为UTF8 character-set-server=UTF8MB4 #创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=UTF8MB4 # mysqlsock存储目录 sockct=E:\\mysql-dc\\data\\mysql.sock [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 derault-character-set=utf8 [mysqld_safe] log-error=E:\\mysql-dc\\logs\\mysql.log pid-file=E:\\mysql-dc\\logs\\mysql.pid # mysqlsock存储目录 socket=E:\\mysql-dc\\data\\mysql.sock ","link":"https://blog.coolcode.dev/post/MySQL的myini配置文件-mysql的myini配置文件/"},{"title":"Chrome打不开https网站，提示：您的连接不是私密连接？","content":"解决办法： 打开chrome://flags 找到“Show in-form warnings for sensitive fields when the top-level page is not HTTPS”设置为 disabled 找到 “Allow invalid certificates for resources loaded from localhost”设置为 “enabled” 点启用，然后重启浏览器 ","link":"https://blog.coolcode.dev/post/Chrome打不开https网站，提示：您的连接不是私密连接？-chrome打不开https网站提示您的连接不是私密连接/"},{"title":"Centos7 防火墙开启 80 443 端口","content":"启用防火墙 systemctl start firewalld.service 开启 80 443 端口 firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=443/tcp --permanent 重启防火墙 firewall-cmd --reload ","link":"https://blog.coolcode.dev/post/Centos7 防火墙开启 80 443 端口-centos7防火墙开启80443端口/"},{"title":"配置 Nginx SSL 证书","content":"前期准备 yum remove epel-release yum clean all yum -y install yum-utils yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional 安装 certbot 以及 certbot nginx 插件 yum install certbot python2-certbot-nginx -y 执行配置，中途会询问你的邮箱，如实填写即可 certbot --nginx 手动续约 service nginx stop certbot --force-renewal 或者使用 certbot --nginx --register-unsafely-without-email 开放80和443端口 firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=443/tcp --permanent firewall-cmd --reload 开放多个端口 firewall-cmd --zone=public --add-port=80-85/tcp --permanent ","link":"https://blog.coolcode.dev/post/配置 Nginx SSL 证书-配置nginxssl证书/"}]}